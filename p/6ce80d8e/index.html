<!DOCTYPE html><html><head><meta charset="utf-8"><title>JVM入门 | 曹耘豪的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="alternate" href="/atom.xml" title="曹耘豪的博客" type="application/atom+xml"><link rel="icon" href="https://s1.ax1x.com/2018/06/09/CbgQqs.png"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="header2" style="border-bottom:1px solid #ccc"><input type="checkbox" id="header-menu-input"><h1 style="text-align:left"><a href="/">曹耘豪的博客</a> <label for="header-menu-input"><svg class="op open" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24" height="24" viewBox="0 0 50 50" fill="currentcolor" stroke="currentcolor"><path d="M 0 7.5 L 0 12.5 L 50 12.5 L 50 7.5 Z M 0 22.5 L 0 27.5 L 50 27.5 L 50 22.5 Z M 0 37.5 L 0 42.5 L 50 42.5 L 50 37.5 Z"></path></svg> <svg class="close" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24" height="24" viewBox="0 0 30 30" style="fill:red"><path d="M 7 4 C 6.744125 4 6.4879687 4.0974687 6.2929688 4.2929688 L 4.2929688 6.2929688 C 3.9019687 6.6839688 3.9019687 7.3170313 4.2929688 7.7070312 L 11.585938 15 L 4.2929688 22.292969 C 3.9019687 22.683969 3.9019687 23.317031 4.2929688 23.707031 L 6.2929688 25.707031 C 6.6839688 26.098031 7.3170313 26.098031 7.7070312 25.707031 L 15 18.414062 L 22.292969 25.707031 C 22.682969 26.098031 23.317031 26.098031 23.707031 25.707031 L 25.707031 23.707031 C 26.098031 23.316031 26.098031 22.682969 25.707031 22.292969 L 18.414062 15 L 25.707031 7.7070312 C 26.098031 7.3170312 26.098031 6.6829688 25.707031 6.2929688 L 23.707031 4.2929688 C 23.316031 3.9019687 22.682969 3.9019687 22.292969 4.2929688 L 15 11.585938 L 7.7070312 4.2929688 C 7.5115312 4.0974687 7.255875 4 7 4 z"></path></svg></label> <input disabled id="local-search-input" class="input-text" type="search" placeholder="js未开启，无法搜索" aria-label="Search"></h1><div id="local-search-result"></div><div class="header-menu" for="header-menu-input"><aside id="sidebar"><div><div class="widget-wrap widget-category"><h3 class="widget-title">目录</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/category/other/">其他</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/">技术</a><span class="category-list-count">137</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/category/technology/cpp/">C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/Go/">Go</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/java/">Java</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/python/">Python</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/Rust/">Rust</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/machine-learning/">机器学习</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/computer-network/">计算机网络</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/design-pattern/">设计模式</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E8%AF%B4%E8%AF%B4/">说说</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E8%BF%90%E7%BB%B4/">运维</a><span class="category-list-count">13</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/category/algorithm/">算法</a><span class="category-list-count">8</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签</h3><div class="widget"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">MySQL</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Protobuf/" rel="tag">Protobuf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/" rel="tag">Spring Cloud</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Feign/" rel="tag">Feign</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" rel="tag">问题排查</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nextjs/" rel="tag">Nextjs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">Spring</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">JVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/" rel="tag">Gradle</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fastjson/" rel="tag">fastjson</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hive/" rel="tag">Hive</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HBase/" rel="tag">HBase</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">响应式编程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">其他</h3><div class="widget"><a href="/atom.xml">RSS Feed </a><a href="/resume" style="margin-left:8px">Resume</a></div></div></div></aside></div><script src="/js/search.js"></script><script type="text/javascript">(()=>{var e="local-search-input",a=(($input=document.getElementById(e)).disabled=!1,$input.placeholder="全站本地搜索","search.json"),a="/"+(a=0===a.length?"search.json":a);searchFunc(a,e,"local-search-result")})()</script></div><article id="post-6ce80d8e" class="article article-type-post" itemscope itemprop="blogPost" style="position:relative"><header><h1 class="article-title" itemprop="name">JVM入门</h1></header><div class="secondary-bg" style="border:1px solid gray;border-radius:4px"><ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-nav-text">类加载机制</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="toc-nav-text">类加载时机</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-nav-text">类加载过程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-nav-text">加载阶段</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5"><span class="toc-nav-text">验证阶段</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-nav-text">准备阶段</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%A7%A3%E6%9E%90%E9%98%B6%E6%AE%B5"><span class="toc-nav-text">解析阶段</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-nav-text">初始化阶段</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%B1%BB%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7"><span class="toc-nav-text">类的唯一性</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-nav-text">类加载器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-nav-text">JVM类加载机制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">双亲委派模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">工作流程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-nav-text">双亲委派机制</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-nav-text">自定义类加载器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#JVM%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">JVM线程模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">Java 内存模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-nav-text">volatile关键字</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">Java的线程实现</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">线程实现的几种方式</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Java%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">Java的实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-nav-text">线程调度</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-nav-text">协程</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-nav-text">JVM内存模型</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98-%E6%9C%80%E5%A4%A7"><span class="toc-nav-text">堆内存 - 最大</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-nav-text">方法区</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%A0%88-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89"><span class="toc-nav-text">栈 - 线程私有</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-nav-text">本地方法栈</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-nav-text">直接内存</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#JVM%E4%B9%8BGC"><span class="toc-nav-text">JVM之GC</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="toc-nav-text">对象存活判断方式</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-Python"><span class="toc-nav-text">1. 引用计数 (Python)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90-Java"><span class="toc-nav-text">2. 可达性分析 (Java)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-nav-text">Java的四种引用</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#finalize"><span class="toc-nav-text">finalize</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BAGC"><span class="toc-nav-text">方法区GC</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-nav-text">垃圾收集算法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-nav-text">分代收集理论</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-nav-text">标记-清除算法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-nav-text">标记-复制算法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-nav-text">标记-整理算法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%81%9C%E9%A1%BF%E6%97%B6%E6%9C%BA%E3%80%81%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-nav-text">用户线程停顿时机、安全点与安全区域</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%81%9C%E9%A1%BF%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-nav-text">停顿的两种方案</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">垃圾收集器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">Serial收集器</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">ParNew收集器</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">Parallel Scavenge收集器</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">Serial Old收集器</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">Parallel Old 收集器</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">CMS收集器</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88Garbage-First%EF%BC%89"><span class="toc-nav-text">G1收集器（Garbage First）</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Shenandoah%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-nav-text">Shenandoah收集器</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#ZGC"><span class="toc-nav-text">ZGC</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88"><span class="toc-nav-text">垃圾收集器组合</span></a></li></ol></li></ol></div><span id="more"></span><blockquote><p>Update on 2023&#x2F;02&#x2F;27</p></blockquote><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>分为<strong>隐式加载</strong>和<strong>显示加载</strong></p><p>隐式加载：</p><ul><li>创建类的实例（<code>new</code>）、访问静态变量（<code>getstatic</code>）、修改静态变量（<code>putstatic</code>）、调用静态方法（<code>invokestatic</code>）</li><li>反射调用</li><li>加载子类时，父类会先被加载</li><li>JVM启动时被标明为启动类的类，直接使用 <code>java.exe</code> 命令来运行的主类</li></ul><p>显示加载：</p><ul><li>通过<code>Class.forName</code>加载，默认执行<code>static</code>块</li><li>通过<code>ClassLoader.loaderClass</code>加载，不执行<code>static</code>块</li><li>通过<code>ClassLoader.findClass</code>加载</li></ul><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>包括<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>、<strong>初始化</strong>五个阶段。</p><p>在这五个阶段中，<strong>加载</strong>、<strong>验证</strong>、<strong>准备</strong>和<strong>初始化</strong>这四个阶段发生的顺序是确定的，而<strong>解析</strong>阶段则不一定，它在某些情况下可以在<strong>初始化</strong>阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><ul><li>获取类的二进制字节流<ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>运行时计算生成。如动态代理技术</li><li>从数据库中提取.class文件</li></ul></li><li>将字节流转化为<strong>方法区</strong>的运行时数据结构</li><li>生成<code>Class</code>对象</li></ul><h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4><ul><li>文件格式验证：是否符合Class文件规范</li><li>元数据验证</li><li>字节码验证：分析数据流、控制流，确保语义合法</li><li>符号引用验证（发生在<strong>解析</strong>阶段）</li></ul><h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>为类的静态变量在<strong>方法区</strong>分配内存，并将其初始化为默认值</p><ul><li>这时候进行内存分配的<strong>仅包括静态变量</strong></li><li>这里所设置的初始值通常情况下是数据类型默认的零值（如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等），而不是被在Java代码中被显式地赋予的值。比如 <code>static int value = 3;</code> 初始化后 <code>value</code>的值为 <code>0</code>。而 <code>static final int value = 3;</code> 初始化后 <code>value</code>的值为 <code>3</code></li></ul><p>注意：</p><ul><li>对基本数据类型来说，对于类变量和静态变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过</li><li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被<code>final</code>修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，<strong>系统不会为其赋予默认零值</strong></li><li>对于引用数据类型来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code></li><li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认零值</li></ul><h4 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h4><p>将常量池内的<strong>符号引用</strong>替换为<strong>直接引用</strong></p><h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>为静态变量赋予正确的初始值</p><ul><li>声明静态变量为指定初始值</li><li>使用<strong>静态代码块</strong>为类变量指定初始值</li></ul><h3 id="类的唯一性"><a href="#类的唯一性" class="headerlink" title="类的唯一性"></a>类的唯一性</h3><p>一个类的唯一性由以下2点决定：</p><ul><li>加载该类的<strong>类加载器</strong></li><li>类的<strong>完全限定名</strong>（包+类名）</li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li><strong>启动类加载器</strong>： <code>BootstrapClassLoader</code>，负责加载存放在 <code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被 -Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如<code>rt.jar</code>，所有的<code>java.</code>开头的类均被 <code>BootstrapClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。</li><li><strong>扩展类加载器</strong>： <code>ExtensionClassLoader</code>，该加载器由 <code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 <code>JDK\jre\lib\ext</code>目录中，或者由 <code>java.ext.dirs</code>系统变量指定的路径中的所有类库（<code>如javax.</code>开头的类），开发者可以直接使用扩展类加载器。</li><li><strong>应用程序类加载器</strong>： <code>ApplicationClassLoader</code>，该类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（<code>ClassPath</code>）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">System.out.println(loader);</span><br><span class="line">System.out.println(loader.getParent());</span><br><span class="line">System.out.println(loader.getParent().getParent());</span><br></pre></td></tr></table></figure><p>结果：（<code>BootstrapLoader</code>（引导类加载器）是用C语言实现的，所以返回为<code>null</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launche r$AppClassLoader@64fef26a</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@1ddd40f3</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h3><ul><li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li><li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li><li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么<strong>修改Class后，必须重启JVM，程序的修改才会生效</strong></li></ul><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给<strong>父加载器</strong>去完成，</p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><ol><li>当<code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li><li>当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</li><li>如果<code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 <code>ExtClassLoader</code>来尝试加载；</li><li>若<code>ExtClassLoader</code>也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</li></ol><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><ol><li>继承<code>ClassLoader</code></li><li>实现<code>findClass</code>方法，其中调用<code>defineClass</code>将字节码转为<code>Class</code>对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes; <span class="comment">// Loaded class binary;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JVM线程模型"><a href="#JVM线程模型" class="headerlink" title="JVM线程模型"></a>JVM线程模型</h2><h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><ul><li>主内存：虚拟机内存，也是物理内存</li><li>工作内存：线程级内存</li></ul><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>功能：</p><ul><li>可见性</li><li>禁止指令重排优化<ul><li>指令重排优化：线程内保证串行</li></ul></li></ul><p>原理：</p><ul><li>内存屏障</li></ul><h3 id="Java的线程实现"><a href="#Java的线程实现" class="headerlink" title="Java的线程实现"></a>Java的线程实现</h3><h4 id="线程实现的几种方式"><a href="#线程实现的几种方式" class="headerlink" title="线程实现的几种方式"></a>线程实现的几种方式</h4><ul><li>1:1：内核线程，一般通过<strong>轻量级进程</strong>(<strong>LWP</strong>)实现</li><li>1:N：用户线程(User Thread，UT)：应用自己调度</li><li>N:M：轻量级进程作为用户线程和内核线程的桥梁，用户线程通过轻量级进程完成</li></ul><h4 id="Java的实现"><a href="#Java的实现" class="headerlink" title="Java的实现"></a>Java的实现</h4><p>1.2之前，Classic虚拟机使用“Green Thread”用户线程，之后都是1:1线程模型</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ul><li>协同式线程调度<ul><li>由线程决定执行时间</li><li>不稳定</li><li>Windows 3.x</li></ul></li><li>抢占式线程调度<ul><li>Java线程调度，<code>Thread::yield()</code>主动让出线程，有10个线程优先级</li></ul></li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li>协同式线程调度，有栈协程</li><li>Java官方解决方案：纤程(Fiber)</li></ul><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><h3 id="堆内存-最大"><a href="#堆内存-最大" class="headerlink" title="堆内存 - 最大"></a>堆内存 - 最大</h3><p>存放对象实例，几乎所有的对象实例都在这里分配内存。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>存类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="栈-线程私有"><a href="#栈-线程私有" class="headerlink" title="栈 - 线程私有"></a>栈 - 线程私有</h3><p>每个方法被执行的时候都会同时创建一个<strong>栈帧</strong>（Stack Frame）用于存储<strong>局部变量表</strong>、<strong>操作栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。</p><ul><li>局部创建的实例由堆分配内存，由GC回收</li><li><strong>程序计数器</strong></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><h2 id="JVM之GC"><a href="#JVM之GC" class="headerlink" title="JVM之GC"></a>JVM之GC</h2><h3 id="对象存活判断方式"><a href="#对象存活判断方式" class="headerlink" title="对象存活判断方式"></a>对象存活判断方式</h3><h4 id="1-引用计数-Python"><a href="#1-引用计数-Python" class="headerlink" title="1. 引用计数 (Python)"></a>1. 引用计数 (Python)</h4><p>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p><h4 id="2-可达性分析-Java"><a href="#2-可达性分析-Java" class="headerlink" title="2. 可达性分析 (Java)"></a>2. 可达性分析 (Java)</h4><p>从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p>在Java语言中，GC Roots包括：</p><ul><li>虚拟机栈中引用的对象，比如方法堆栈使用的参数、局部变量等</li><li>方法区中类静态属性实体引用的对象，比如引用类型静态变量</li><li>方法区中常量引用的对象，比如字符串常量</li><li>本地方法栈中JNI引用的对象，比如native方法引用的对象</li><li>虚拟机内部的引用，比如Class对象</li><li>所有被同步锁（synchronized）持有的对象</li><li>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul><h3 id="Java的四种引用"><a href="#Java的四种引用" class="headerlink" title="Java的四种引用"></a>Java的四种引用</h3><ul><li>强引用（Strongly Reference）：传统引用，只要存在强引用，就不会被回收</li><li>软引用（Soft Reference）：如果下次gc后内存依然不足，则被回收</li><li>弱引用（Weak Reference）：下次gc回收</li><li>虚引用（Phantom Reference）：下次gc回收，引用者会收到系统通知。无法通过该引用方式获取实例。也称“幽灵引用”</li></ul><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><ul><li>仅执行一次，即使该对象在finalize里被“拯救”</li><li>gc线程不会等待finalize函数执行完毕</li></ul><h3 id="方法区GC"><a href="#方法区GC" class="headerlink" title="方法区GC"></a>方法区GC</h3><ul><li>常量池回收</li><li>类型回收</li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短</p><p>“分代收集”（Generational Collection）算法，把Java堆分为<strong>新生代</strong>（Young Generation）和<strong>老年代</strong>（Old Generation），这样就可以根据各个年代的特点采用最适当的收集算法。</p><ul><li>新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用“<strong>标记-复制</strong>”算法，只需要付出少量存活对象的复制成本就可以完成收集</li><li>老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“<strong>标记-清除</strong>”或“<strong>标记-整理</strong>”算法来进行回收</li></ul><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>“标记-清除”（Mark-Sweep）算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p><p>缺点：</p><ul><li>效率问题，标记和清除过程的效率都不高；</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h4 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h4><p>“标记-复制”（Mark-Coping）算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。</p><ul><li>在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在<strong>老年代</strong>一般不能直接选用这种算法。</li></ul><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><h3 id="用户线程停顿时机、安全点与安全区域"><a href="#用户线程停顿时机、安全点与安全区域" class="headerlink" title="用户线程停顿时机、安全点与安全区域"></a>用户线程停顿时机、安全点与安全区域</h3><p>安全点：触发GC时，程序需运行至特定的位置然后停顿，一般是指令序列的复用点，如<strong>方法调用</strong>、<strong>循环跳转</strong>、<strong>异常跳转</strong>等。</p><h4 id="停顿的两种方案"><a href="#停顿的两种方案" class="headerlink" title="停顿的两种方案"></a>停顿的两种方案</h4><ol><li>抢先式中断（Preemptive Suspension）<ul><li>GC发出中断信号，用户线程判断是否在安全点，如果不在则继续运行至安全点</li></ul></li><li>主动式中断（Voluntary Suspension）<ul><li>在安全点设置轮询标志，如果发现中断标志则在最近的安全点主动挂起</li></ul></li></ol><p>安全区域：在一段代码片段中，引用关系不会发生变化</p><ul><li>进入安全区域后，Stop the world对其无效</li><li>即将离开安全区域时，会检查是否存在停顿事件，如果存在则停顿</li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>Serial收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。垃圾收集的过程中会Stop The World（服务暂停）</p><ul><li>新生代“标记-复制”算法、老年代“标记-整理”</li><li>单线程，资源少，效率高</li><li>多应用于客户端</li></ul><h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>ParNew收集器其实就是Serial收集器的多线程版本</p><ul><li>“标记-复制”算法</li><li>新生代多线程</li><li>只有它能配合CMS收集器</li></ul><h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器类似ParNew收集器，Parallel Scavenge收集器更关注系统的吞吐量</p><ul><li>更关注可控制的吞吐量</li><li>多线程GC</li></ul><h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本</p><ul><li>配合Parallel Scavenge使用</li><li>CMS收集器失败的后备预案</li></ul><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和算法。这个收集器是在JDK 1.6中才开始提供</p><ul><li>多线程GC，“标记-整理”算法</li><li>配合Parallel Scavenge使用</li><li>注重吞吐量和处理器资源稀缺的场景</li></ul><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p><ul><li>并发</li><li>停顿时间短</li><li>产生大量空间碎片、并发阶段会降低吞吐量。因为是“<strong>标记-清除</strong>”算法</li><li>服务器资源敏感</li><li>用户线程改变引用，使用<strong>增量更新</strong>（Incremental Update）算法</li></ul><p>收集步骤：</p><ol><li><p>初始标记（CMS initial mark）</p><ul><li>Stop The World</li><li>仅标记一下GC Roots能直接关联到的对象</li></ul></li><li><p>并发标记（CMS concurrent mark）</p><ul><li>GC Roots Tracing</li><li>和用户线程并行</li></ul></li><li><p>重新标记（CMS remark）：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</p><ul><li>Stop The World</li><li>这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短</li></ul></li><li><p>并发清除（CMS concurrent sweep）</p></li></ol><h4 id="G1收集器（Garbage-First）"><a href="#G1收集器（Garbage-First）" class="headerlink" title="G1收集器（Garbage First）"></a>G1收集器（Garbage First）</h4><ul><li>将堆分为大小相等的Region（1MB～32MB且为2的N次幂），每个Region都可以扮演新生代的Eden空间、Survivor空间或者老年代空间<ul><li>每个Region维护“记忆集”，用来保存“我指向谁”、“谁指向我”</li><li>用户线程改变引用，使用<strong>原始快照</strong>（snapshot-at-the-beginning，SATB）算法</li></ul></li><li>Humongous空间，专门用来存储大对象。超过Region大小的一半</li><li>优先处理回收价值大的Region</li><li>停顿预测模型</li></ul><p>收集步骤：</p><ol><li>初始标记（Initial Mark）：标记GC Root关联的对象<ul><li>Stop the World</li><li>由普通Mintor GC伴随触发</li></ul></li><li>并发标记（Concurrent Marking）：进行可达性分析<ul><li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断</li><li>若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收</li><li>标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</li></ul></li><li>最终标记（Final Marking）：再标记“并发标记期间产生新的垃圾”<ul><li>Stop the World</li><li>处理SATB表（原始快照）</li></ul></li><li>筛选回收（Live Data Counting and Evacuation），<ul><li>Stop the World</li><li>根据用户期望的停顿时间来制定回收计划</li><li>把决定回收的那一部分Region的存活对象复制到空的Region中，在清理掉整个旧Region的全部空间</li><li>并行</li></ul></li></ol><h4 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h4><p>和G1收集器类似，不同点有：</p><ul><li>整理时与用户线程并发</li><li>默认不使用分代收集</li><li>记忆集修改为“连接矩阵（Connection Matrix）”</li><li>与用户进程并行收集<ul><li>Brooks Pointer，在对象布局结构前增肌一个新的引用字段，一开始指向自己，间接性的对象访问</li><li>使用CAS（Compare And Swap）保证并发访问的正确性</li></ul></li><li>第一款使用读屏障的收集器，读屏障比写屏障的代价更高</li></ul><h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><p>Region分布</p><ul><li>小型Region，2MB，存放小于256KB的小对象</li><li>中型Region，32MB，存放大于等于256KB但小于4MB的对象</li><li>大型Region，必须为2MB的整数倍，放置大于等于4MB的对象，只放一个对象</li></ul><p>并发整理算法——指针颜色技术</p><ul><li>Linux高18位不能用来寻址，剩余46位，将46位的前4位用来染色，分别是“finalizable”、“Remapped”，“Marked1”、“Marked0”，剩余42位导致ZGC最多支持4TB内存。不能使用32位系统和指针压缩</li><li>x86-64平台，使用虚拟内存映射技术</li></ul><p>支持“NUMA-Aware”的内存分配，ZGC收集器会优先尝试在请求线程当前所处的处理器的本地内存上分配对象，以保证高效内存访问。</p><ul><li>NUMA是非统一内存访问架构，简单说就是内存控制器分配给处理器内核，如果一个内核要访问被其他内核管理的内存，必须通过Inter-Connect通道，这比访问自己管理的内存慢得多，这种访问成为“跨NUMA”</li></ul><p>步骤：</p><ol><li>并发标记：标记指针中的Marked1和Marked0标志位</li><li>并发预备重分配：根据特定的查询条件统计得出本次收集过程中要清理哪些Region<ul><li>扫描所有Region</li><li>类卸载和弱引用处理</li></ul></li><li>并发重分配<ul><li>每个Region维护转发表。外部引用会被内存屏障截获，然后更新该引用的值，所以只有第一次访问旧对象会慢</li></ul></li><li>并发重映射：修正所有引用<ul><li>合并到下一次的“合并标记”阶段</li></ul></li></ol><h3 id="垃圾收集器组合"><a href="#垃圾收集器组合" class="headerlink" title="垃圾收集器组合"></a>垃圾收集器组合</h3><table><thead><tr><th align="left">组合</th><th>新生代GC策略</th><th>老年代GC策略</th><th>说明</th></tr></thead><tbody><tr><td align="left">组合1</td><td>Serial</td><td>Serial Old</td><td>单线程，适合客户端</td></tr><tr><td align="left">组合2</td><td>Serial</td><td>CMS+Serial Old</td><td>当CMS进行GC失败时，会自动使用Serial Old。</td></tr><tr><td align="left">组合3</td><td>ParNew</td><td>CMS</td><td></td></tr><tr><td align="left">组合4</td><td>ParNew</td><td>Serial Old</td><td></td></tr><tr><td align="left">组合5</td><td>Parallel Scavenge</td><td>Serial Old</td><td>适用于后台持久运行的应用程序</td></tr><tr><td align="left">组合6</td><td>Parallel Scavenge</td><td>Parallel Old</td><td></td></tr><tr><td align="left">组合7</td><td>G1</td><td>G1</td><td></td></tr></tbody></table><div style="border-top:2px solid #eee;height:1px;margin:8px 0"></div><div class="article-category"><svg class="i-tag" width="16px" height="16px" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.41959 3.23866C6.23018 3.05852 7.19557 3 8.312 3H9.92963C10.9327 3 11.8694 3.5013 12.4258 4.3359L13.2383 5.5547C13.4238 5.83288 13.736 6 14.0704 6H19.1258C20.7233 6 22.0181 7.26115 22.0029 8.8852C21.9847 10.8192 22 12.7539 22 14.688C22 15.8044 21.9415 16.7698 21.7613 17.5804C21.5787 18.4024 21.2579 19.1251 20.6915 19.6915C20.1251 20.2579 19.4024 20.5787 18.5804 20.7613C17.7698 20.9415 16.8044 21 15.688 21H8.312C7.19557 21 6.23018 20.9415 5.41959 20.7613C4.59764 20.5787 3.87488 20.2579 3.30848 19.6915C2.74209 19.1251 2.42133 18.4024 2.23866 17.5804C2.05852 16.7698 2 15.8044 2 14.688V9.312C2 8.19557 2.05852 7.23018 2.23866 6.41959C2.42133 5.59764 2.74209 4.87488 3.30848 4.30848C3.87488 3.74209 4.59764 3.42133 5.41959 3.23866ZM8.19103 13.8535C8.05868 14.449 8 15.2412 8 16.312V18C8 18.5523 7.55228 19 7 19C6.44772 19 6 18.5523 6 18V16.312C6 15.1956 6.05852 14.2302 6.23866 13.4196C6.42133 12.5976 6.74209 11.8749 7.30848 11.3085C7.87488 10.7421 8.59764 10.4213 9.41959 10.2387C10.2302 10.0585 11.1956 10 12.312 10H17.688H19C19.5523 10 20 10.4477 20 11C20 11.5523 19.5523 12 19 12H17.688H12.312C11.2412 12 10.449 12.0587 9.85349 12.191C9.26933 12.3209 8.9375 12.5079 8.72269 12.7227C8.50789 12.9375 8.32085 13.2693 8.19103 13.8535Z"/></svg> &nbsp; <a class="article-category-link" href="/category/technology/">技术</a>&nbsp;/&nbsp;<a class="article-category-link" href="/category/technology/java/">Java</a></div><div class="article-tag"><svg class="i-tag" width="16" height="16" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.678 11.422a2.5 2.5 0 0 0 0 3.536l6.364 6.364a2.5 2.5 0 0 0 3.536 0l7.69-7.69A2.5 2.5 0 0 0 21 11.864V4.5A1.5 1.5 0 0 0 19.5 3h-7.365a2.5 2.5 0 0 0-1.768.732l-7.69 7.69zM14.988 7C13.878 7 13 7.832 13 8.988c0 1.157.878 2.012 1.988 2.012C16.121 11 17 10.145 17 8.988 17 7.832 16.12 7 14.988 7z"/></svg> &nbsp; <a class="article-tag-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></div><div class="article-date"><time datetime="2018-04-18T16:00:00.000Z" itemprop="datePublished">2018-04-19</time></div></article></body></html>