<!DOCTYPE html><html><head><meta charset="utf-8"><title>算法之排序 | 曹耘豪的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="alternate" href="/atom.xml" title="曹耘豪的博客" type="application/atom+xml"><link rel="icon" href="https://s1.ax1x.com/2018/06/09/CbgQqs.png"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="header2" style="border-bottom:1px solid #ccc"><input type="checkbox" id="header-menu-input"><h1 style="text-align:left"><a href="/">曹耘豪的博客</a> <label for="header-menu-input"><svg class="op open" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24" height="24" viewBox="0 0 50 50" fill="currentcolor" stroke="currentcolor"><path d="M 0 7.5 L 0 12.5 L 50 12.5 L 50 7.5 Z M 0 22.5 L 0 27.5 L 50 27.5 L 50 22.5 Z M 0 37.5 L 0 42.5 L 50 42.5 L 50 37.5 Z"></path></svg> <svg class="close" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24" height="24" viewBox="0 0 30 30" style="fill:red"><path d="M 7 4 C 6.744125 4 6.4879687 4.0974687 6.2929688 4.2929688 L 4.2929688 6.2929688 C 3.9019687 6.6839688 3.9019687 7.3170313 4.2929688 7.7070312 L 11.585938 15 L 4.2929688 22.292969 C 3.9019687 22.683969 3.9019687 23.317031 4.2929688 23.707031 L 6.2929688 25.707031 C 6.6839688 26.098031 7.3170313 26.098031 7.7070312 25.707031 L 15 18.414062 L 22.292969 25.707031 C 22.682969 26.098031 23.317031 26.098031 23.707031 25.707031 L 25.707031 23.707031 C 26.098031 23.316031 26.098031 22.682969 25.707031 22.292969 L 18.414062 15 L 25.707031 7.7070312 C 26.098031 7.3170312 26.098031 6.6829688 25.707031 6.2929688 L 23.707031 4.2929688 C 23.316031 3.9019687 22.682969 3.9019687 22.292969 4.2929688 L 15 11.585938 L 7.7070312 4.2929688 C 7.5115312 4.0974687 7.255875 4 7 4 z"></path></svg></label> <input disabled id="local-search-input" class="input-text" type="search" placeholder="js未开启，无法搜索" aria-label="Search"></h1><div id="local-search-result"></div><div class="header-menu" for="header-menu-input"><aside id="sidebar"><div><div class="widget-wrap widget-category"><h3 class="widget-title">目录</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/category/other/">其他</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/">技术</a><span class="category-list-count">137</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/category/technology/cpp/">C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/Go/">Go</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/java/">Java</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/python/">Python</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/Rust/">Rust</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/machine-learning/">机器学习</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/computer-network/">计算机网络</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/design-pattern/">设计模式</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E8%AF%B4%E8%AF%B4/">说说</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E8%BF%90%E7%BB%B4/">运维</a><span class="category-list-count">13</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/category/algorithm/">算法</a><span class="category-list-count">8</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签</h3><div class="widget"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">MySQL</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Protobuf/" rel="tag">Protobuf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/" rel="tag">Spring Cloud</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Feign/" rel="tag">Feign</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" rel="tag">问题排查</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nextjs/" rel="tag">Nextjs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">Spring</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">JVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/" rel="tag">Gradle</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fastjson/" rel="tag">fastjson</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hive/" rel="tag">Hive</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HBase/" rel="tag">HBase</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">响应式编程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">其他</h3><div class="widget"><a href="/atom.xml">RSS Feed </a><a href="/resume" style="margin-left:8px">Resume</a></div></div></div></aside></div><script src="/js/search.js"></script><script type="text/javascript">(()=>{var e="local-search-input",a=(($input=document.getElementById(e)).disabled=!1,$input.placeholder="全站本地搜索","search.json"),a="/"+(a=0===a.length?"search.json":a);searchFunc(a,e,"local-search-result")})()</script></div><article id="post-ab08525f" class="article article-type-post" itemscope itemprop="blogPost" style="position:relative"><header><h1 class="article-title" itemprop="name">算法之排序</h1></header><div class="secondary-bg" style="border:1px solid gray;border-radius:4px"><ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88Bubble-Sort%EF%BC%89"><span class="toc-nav-text">冒泡排序（Bubble Sort）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Selection-Sort%EF%BC%89"><span class="toc-nav-text">选择排序（Selection Sort）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion-Sort%EF%BC%89"><span class="toc-nav-text">插入排序（Insertion Sort）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Shell-Sort%EF%BC%89"><span class="toc-nav-text">希尔排序（Shell Sort）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Heap-Sort%EF%BC%89"><span class="toc-nav-text">堆排序（Heap Sort）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Merge-Sort%EF%BC%89"><span class="toc-nav-text">归并排序（Merge Sort）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Quick-Sort%EF%BC%89"><span class="toc-nav-text">快速排序（Quick Sort）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Counting-Sort%EF%BC%89"><span class="toc-nav-text">计数排序（Counting Sort）</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Radix-Sort%EF%BC%89"><span class="toc-nav-text">基数排序（Radix Sort）</span></a></li></ol></div><span id="more"></span><blockquote><p>可视化排序 <a href="https://visualgo.net/en/sorting">https://visualgo.net/en/sorting</a></p></blockquote><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>依次两两比较，发现顺序不对则交换，重复这一过程</p><p>由于是从前向后遍历，所以第一次遍历会将最大的交换至最后一个位置，依次类推</p><p>我们记录每次遍历时最后一次交换的位置，避免后续多余的判断</p><ul><li>稳定排序算法</li><li>时间复杂度：<em>O(n^2)</em></li><li>空间复杂度：<em>O(1)</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    last_sort, swap_count = <span class="built_in">len</span>(arr), <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> last_sort &gt; <span class="number">1</span>:</span><br><span class="line">        last_sort, end = <span class="number">1</span>, last_sort</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, end):</span><br><span class="line">            <span class="keyword">if</span> arr[i - <span class="number">1</span>] &gt; arr[i]:</span><br><span class="line">                arr[i - <span class="number">1</span>], arr[i] = arr[i], arr[i - <span class="number">1</span>]</span><br><span class="line">                last_sort = i</span><br><span class="line">                swap_count += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>每次选择最小值放到前面</p><ul><li>不稳定排序算法</li><li>复杂度：<em>O(n^2)</em></li><li>空间复杂度：<em>O(1)</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selection_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    swap_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_idx]:</span><br><span class="line">                min_idx = j</span><br><span class="line">        <span class="keyword">if</span> min_idx != i:</span><br><span class="line">            swap_count += <span class="number">1</span></span><br><span class="line">            arr[i], arr[min_idx] = arr[min_idx], arr[i]</span><br></pre></td></tr></table></figure><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>依次选择元素，插入到前面已排序的位置</p><ul><li>稳定排序算法</li><li>复杂度：<em>O(n^2)</em></li><li>空间复杂度：<em>O(1)</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertion_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    swap_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        j = i</span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">1</span> <span class="keyword">and</span> arr[j - <span class="number">1</span>] &gt; arr[j]:</span><br><span class="line">            arr[j - <span class="number">1</span>], arr[j] = arr[j], arr[j - <span class="number">1</span>]</span><br><span class="line">            swap_count += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> swap_count</span><br></pre></td></tr></table></figure><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p>插入排序的优化，也称“递减增量排序算法”，先分组，分组内使用普通插入排序，逐渐增加每个分组内的元素数，最终一个分组内包含全部元素（step&#x3D;1）</p><ul><li>非稳定排序算法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    swap_count = <span class="number">0</span></span><br><span class="line">    step = <span class="built_in">len</span>(arr) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> step:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(step, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="comment"># 以下是普通插入排序</span></span><br><span class="line">            j = i <span class="comment"># j=step时，j是第一个分组的第二个元素</span></span><br><span class="line">            <span class="keyword">while</span> j - step &gt;= <span class="number">0</span> <span class="keyword">and</span> arr[j - step] &gt; arr[j]:</span><br><span class="line">                arr[j - step], arr[j] = arr[j], arr[j - step]</span><br><span class="line">                swap_count += <span class="number">1</span></span><br><span class="line">                j -= step</span><br><span class="line">        step //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> swap_count</span><br></pre></td></tr></table></figure><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p>先将输入数组转化为<strong>最大堆</strong>，然后每次将<strong>堆顶元素</strong>和堆的<strong>最后一个未排序的元素</strong>交换，然后将前面的元素继续堆化</p><ul><li>不稳定排序算法</li><li>时间复杂度：<em>O(nlogn)</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heapify_max</span>(<span class="params">arr, n, i</span>):</span><br><span class="line">    left, right, target = i * <span class="number">2</span> + <span class="number">1</span>, i * <span class="number">2</span> + <span class="number">2</span>, i</span><br><span class="line">    <span class="keyword">if</span> left &lt; n <span class="keyword">and</span> arr[left] &gt; arr[target]:</span><br><span class="line">        target = left</span><br><span class="line">    <span class="keyword">if</span> right &lt; n <span class="keyword">and</span> arr[right] &gt; arr[target]:</span><br><span class="line">        target = right</span><br><span class="line">    <span class="keyword">if</span> target != i:</span><br><span class="line">        arr[target], arr[i] = arr[i], arr[target]</span><br><span class="line">        heapify_max(arr, n, target)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="comment"># 构建最大堆</span></span><br><span class="line">    last_parent = (<span class="built_in">len</span>(arr) - <span class="number">2</span> ) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> parent <span class="keyword">in</span> <span class="built_in">range</span>(last_parent, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        heapify_max(arr, parent, <span class="built_in">len</span>(arr))</span><br><span class="line">    <span class="comment"># 交换后，将前面的元素再次堆化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        arr[<span class="number">0</span>], arr[i] = arr[i], arr[<span class="number">0</span>]</span><br><span class="line">        heapify_max(arr, i, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p>先2个一组，组内排序，然后4个一组，组内排序（相当于合并两个有序列表），然后8个一组，组内排序，依次类推</p><ul><li>稳定排序算法</li><li>复杂度：<em>O(nlogn)</em></li><li>空间复杂度：<em>O(n)</em></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">ll, rr</span>):</span><br><span class="line">        l, r, r_end = ll, rr, <span class="built_in">min</span>(rr + (rr - ll), <span class="built_in">len</span>(arr))</span><br><span class="line">        merged = []</span><br><span class="line">        <span class="keyword">while</span> l &lt; rr <span class="keyword">and</span> r &lt; r_end:</span><br><span class="line">            <span class="keyword">if</span> arr[l] &lt; arr[r]:</span><br><span class="line">                merged.append(arr[l])</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                merged.append(arr[r])</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l, rr):</span><br><span class="line">            merged.append(arr[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r, r_end):</span><br><span class="line">            merged.append(arr[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(merged)):</span><br><span class="line">            arr[ll + i] = merged[i]</span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(arr), i &lt;&lt; <span class="number">1</span>):</span><br><span class="line">            merge(j, j + i)</span><br><span class="line">        i &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(arr):</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p>每次取第一个未排序的值，将小于它的放到左边，大于它的放到右边，把该值放到中间，该值便确定。重复该过程直到全部排序完成</p><ul><li>非稳定排序算法</li><li>复杂度：<em>O(nlogn)<em>，最坏</em>O(nlogn)</em></li><li>空间复杂度：*O(n)*，根据实现方式不同</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    sorted_indices = [<span class="literal">False</span>] * <span class="built_in">len</span>(arr)</span><br><span class="line">    first_unsorted_idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> first_unsorted_idx &lt; <span class="built_in">len</span>(arr):</span><br><span class="line">        pivot_idx = first_unsorted_idx</span><br><span class="line"></span><br><span class="line">        low_store_idx = pivot_idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pivot_idx + <span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">            <span class="keyword">if</span> sorted_indices[i]:</span><br><span class="line">                <span class="comment"># 如果排序过则停止</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> arr[pivot_idx] &gt; arr[i]:</span><br><span class="line">                arr[i], arr[low_store_idx] = arr[low_store_idx], arr[i]</span><br><span class="line">                low_store_idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        arr[pivot_idx], arr[low_store_idx - <span class="number">1</span>] = arr[low_store_idx - <span class="number">1</span>], arr[pivot_idx]</span><br><span class="line">        sorted_indices[low_store_idx - <span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算第一个未排序的位置</span></span><br><span class="line">        <span class="keyword">while</span> first_unsorted_idx &lt; <span class="built_in">len</span>(arr) <span class="keyword">and</span> sorted_indices[first_unsorted_idx]:</span><br><span class="line">            first_unsorted_idx += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h2><p>对一个小范围的整数排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counting_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    base = <span class="built_in">min</span>(arr)</span><br><span class="line">    sort_arr = [<span class="number">0</span>] * (<span class="built_in">max</span>(arr) - base + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">        sort_arr[arr[i] - base] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sort_arr)):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(sort_arr[i]):</span><br><span class="line">            arr[idx] = base + i</span><br><span class="line">            idx += <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h2><p>对每一位分别排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">radix_sort</span>(<span class="params">arr</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取最大位数</span></span><br><span class="line">    max_ = <span class="built_in">max</span>(arr)</span><br><span class="line">    digit_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> max_:</span><br><span class="line">        max_ //= <span class="number">10</span></span><br><span class="line">        digit_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">num, digit</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        获取一个整数的倒数第digit位数</span></span><br><span class="line"><span class="string">        @param digit: 0代表倒数第一位，1代表倒数第二位</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> digit:</span><br><span class="line">            num //= <span class="number">10</span></span><br><span class="line">            digit -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> num % <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(digit_count):</span><br><span class="line">        <span class="comment"># 初始化10个桶</span></span><br><span class="line">        buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> arr:</span><br><span class="line">            digit = get(n, i)</span><br><span class="line">            buckets[digit].append(n)</span><br><span class="line"></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> bucket:</span><br><span class="line">                arr[idx] = n</span><br><span class="line">                idx += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://kjimg10.360buyimg.com/ott/jfs/t1/212533/12/24102/155964/63859ae6E74ecabdc/07ef98658df4b84c.png"></p><div style="border-top:2px solid #eee;height:1px;margin:8px 0"></div><div class="article-category"><svg class="i-tag" width="16px" height="16px" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.41959 3.23866C6.23018 3.05852 7.19557 3 8.312 3H9.92963C10.9327 3 11.8694 3.5013 12.4258 4.3359L13.2383 5.5547C13.4238 5.83288 13.736 6 14.0704 6H19.1258C20.7233 6 22.0181 7.26115 22.0029 8.8852C21.9847 10.8192 22 12.7539 22 14.688C22 15.8044 21.9415 16.7698 21.7613 17.5804C21.5787 18.4024 21.2579 19.1251 20.6915 19.6915C20.1251 20.2579 19.4024 20.5787 18.5804 20.7613C17.7698 20.9415 16.8044 21 15.688 21H8.312C7.19557 21 6.23018 20.9415 5.41959 20.7613C4.59764 20.5787 3.87488 20.2579 3.30848 19.6915C2.74209 19.1251 2.42133 18.4024 2.23866 17.5804C2.05852 16.7698 2 15.8044 2 14.688V9.312C2 8.19557 2.05852 7.23018 2.23866 6.41959C2.42133 5.59764 2.74209 4.87488 3.30848 4.30848C3.87488 3.74209 4.59764 3.42133 5.41959 3.23866ZM8.19103 13.8535C8.05868 14.449 8 15.2412 8 16.312V18C8 18.5523 7.55228 19 7 19C6.44772 19 6 18.5523 6 18V16.312C6 15.1956 6.05852 14.2302 6.23866 13.4196C6.42133 12.5976 6.74209 11.8749 7.30848 11.3085C7.87488 10.7421 8.59764 10.4213 9.41959 10.2387C10.2302 10.0585 11.1956 10 12.312 10H17.688H19C19.5523 10 20 10.4477 20 11C20 11.5523 19.5523 12 19 12H17.688H12.312C11.2412 12 10.449 12.0587 9.85349 12.191C9.26933 12.3209 8.9375 12.5079 8.72269 12.7227C8.50789 12.9375 8.32085 13.2693 8.19103 13.8535Z"/></svg> &nbsp; <a class="article-category-link" href="/category/algorithm/">算法</a></div><div class="article-date"><time datetime="2022-11-23T05:00:00.000Z" itemprop="datePublished">2022-11-23</time></div></article></body></html>