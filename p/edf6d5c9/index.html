<!DOCTYPE html><html><head><meta charset="utf-8"><title>Java并发编程 | 曹耘豪的博客</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="alternate" href="/atom.xml" title="曹耘豪的博客" type="application/atom+xml"><link rel="icon" href="https://s1.ax1x.com/2018/06/09/CbgQqs.png"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="header2" style="border-bottom:1px solid #ccc"><input type="checkbox" id="header-menu-input"><h1 style="text-align:left"><a href="/">曹耘豪的博客</a> <label for="header-menu-input"><svg class="op open" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24" height="24" viewBox="0 0 50 50" fill="currentcolor" stroke="currentcolor"><path d="M 0 7.5 L 0 12.5 L 50 12.5 L 50 7.5 Z M 0 22.5 L 0 27.5 L 50 27.5 L 50 22.5 Z M 0 37.5 L 0 42.5 L 50 42.5 L 50 37.5 Z"></path></svg> <svg class="close" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="24" height="24" viewBox="0 0 30 30" style="fill:red"><path d="M 7 4 C 6.744125 4 6.4879687 4.0974687 6.2929688 4.2929688 L 4.2929688 6.2929688 C 3.9019687 6.6839688 3.9019687 7.3170313 4.2929688 7.7070312 L 11.585938 15 L 4.2929688 22.292969 C 3.9019687 22.683969 3.9019687 23.317031 4.2929688 23.707031 L 6.2929688 25.707031 C 6.6839688 26.098031 7.3170313 26.098031 7.7070312 25.707031 L 15 18.414062 L 22.292969 25.707031 C 22.682969 26.098031 23.317031 26.098031 23.707031 25.707031 L 25.707031 23.707031 C 26.098031 23.316031 26.098031 22.682969 25.707031 22.292969 L 18.414062 15 L 25.707031 7.7070312 C 26.098031 7.3170312 26.098031 6.6829688 25.707031 6.2929688 L 23.707031 4.2929688 C 23.316031 3.9019687 22.682969 3.9019687 22.292969 4.2929688 L 15 11.585938 L 7.7070312 4.2929688 C 7.5115312 4.0974687 7.255875 4 7 4 z"></path></svg></label> <input disabled id="local-search-input" class="input-text" type="search" placeholder="js未开启，无法搜索" aria-label="Search"></h1><div id="local-search-result"></div><div class="header-menu" for="header-menu-input"><aside id="sidebar"><div><div class="widget-wrap widget-category"><h3 class="widget-title">目录</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/category/other/">其他</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/">技术</a><span class="category-list-count">137</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/category/technology/cpp/">C++</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/Go/">Go</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/java/">Java</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/python/">Python</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/Rust/">Rust</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/machine-learning/">机器学习</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/computer-network/">计算机网络</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/design-pattern/">设计模式</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E8%AF%B4%E8%AF%B4/">说说</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/category/technology/%E8%BF%90%E7%BB%B4/">运维</a><span class="category-list-count">13</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/category/algorithm/">算法</a><span class="category-list-count">8</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">标签</h3><div class="widget"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">MySQL</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Protobuf/" rel="tag">Protobuf</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/" rel="tag">Spring Cloud</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Feign/" rel="tag">Feign</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a><span class="tag-list-count">21</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/" rel="tag">问题排查</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nextjs/" rel="tag">Nextjs</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/" rel="tag">Spring</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/" rel="tag">JVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/" rel="tag">Gradle</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fastjson/" rel="tag">fastjson</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mybatis/" rel="tag">Mybatis</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hive/" rel="tag">Hive</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HBase/" rel="tag">HBase</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">响应式编程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">其他</h3><div class="widget"><a href="/atom.xml">RSS Feed </a><a href="/resume" style="margin-left:8px">Resume</a></div></div></div></aside></div><script src="/js/search.js"></script><script type="text/javascript">(()=>{var e="local-search-input",a=(($input=document.getElementById(e)).disabled=!1,$input.placeholder="全站本地搜索","search.json"),a="/"+(a=0===a.length?"search.json":a);searchFunc(a,e,"local-search-result")})()</script></div><article id="post-edf6d5c9" class="article article-type-post" itemscope itemprop="blogPost" style="position:relative"><header><h1 class="article-title" itemprop="name">Java并发编程</h1></header><div class="secondary-bg" style="border:1px solid gray;border-radius:4px"><ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-nav-text">Java线程池原理分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-nav-text">构造函数的参数</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#corePoolSize"><span class="toc-nav-text">corePoolSize</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#maximumPoolSize"><span class="toc-nav-text">maximumPoolSize</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#keepAliveTime%EF%BC%8Cunit"><span class="toc-nav-text">keepAliveTime，unit</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#workQueue"><span class="toc-nav-text">workQueue</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#threadFactory"><span class="toc-nav-text">threadFactory</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#handler"><span class="toc-nav-text">handler</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81ctl%E5%AD%97%E6%AE%B5"><span class="toc-nav-text">内部状态ctl字段</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#execute%E6%96%B9%E6%B3%95"><span class="toc-nav-text">execute方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#getTask%E6%96%B9%E6%B3%95"><span class="toc-nav-text">getTask方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#runWorker%E6%96%B9%E6%B3%95"><span class="toc-nav-text">runWorker方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#submit%E6%96%B9%E6%B3%95"><span class="toc-nav-text">submit方法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#FutureTask"><span class="toc-nav-text">FutureTask</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8CAQS"><span class="toc-nav-text">阻塞队列和AQS</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#offer%E6%96%B9%E6%B3%95%EF%BC%8C%E9%98%BB%E5%A1%9E%E6%B7%BB%E5%8A%A0"><span class="toc-nav-text">offer方法，阻塞添加</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#poll%E6%96%B9%E6%B3%95%EF%BC%8C%E9%98%BB%E5%A1%9E%E8%8E%B7%E5%8F%96"><span class="toc-nav-text">poll方法，阻塞获取</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#await%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-nav-text">await实现原理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#AQS%EF%BC%88AbstractQueuedSynchronizer%EF%BC%8C%E6%8A%BD%E8%B1%A1%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%EF%BC%89"><span class="toc-nav-text">AQS（AbstractQueuedSynchronizer，抽象队列同步器）</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Unsafe-park-absolute-time"><span class="toc-nav-text">Unsafe.park(absolute, time)</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Unsafe-unpark-thread"><span class="toc-nav-text">Unsafe.unpark(thread)</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%82%E8%80%83"><span class="toc-nav-text">参考</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#CompletionService"><span class="toc-nav-text">CompletionService</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-nav-text">背景</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BC%A0%E7%BB%9F%E5%86%99%E6%B3%95"><span class="toc-nav-text">传统写法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8CompletionService"><span class="toc-nav-text">如果使用CompletionService</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#CompletionService%E5%8E%9F%E7%90%86"><span class="toc-nav-text">CompletionService原理</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%85%B6%E4%BB%96%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-nav-text">其他使用场景</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%8F%96%E5%87%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%88%90%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-nav-text">取出第一个完成的结果</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%99%90%E6%97%B6%E5%86%85%E5%8F%96%E5%87%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%9D%9Enull%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-nav-text">限时内取出第一个非null的结果</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ConcurrentHashMap%E5%8E%9F%E7%90%86"><span class="toc-nav-text">ConcurrentHashMap原理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96Table"><span class="toc-nav-text">初始化Table</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Get%E6%96%B9%E6%B3%95"><span class="toc-nav-text">Get方法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#find%E6%96%B9%E6%B3%95"><span class="toc-nav-text">find方法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Put%E6%96%B9%E6%B3%95"><span class="toc-nav-text">Put方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#transfer%E6%89%A9%E5%AE%B9"><span class="toc-nav-text">transfer扩容</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%82%E8%80%83-1"><span class="toc-nav-text">参考</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#CompletableFuture"><span class="toc-nav-text">CompletableFuture</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%9E%84%E9%80%A0CompletableFuture"><span class="toc-nav-text">构造CompletableFuture</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8%EF%BC%88%E5%BC%82%E6%AD%A5%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-nav-text">链式调用（异步顺序执行）</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95"><span class="toc-nav-text">工具方法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-nav-text">注意事项</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-nav-text">同步操作的线程问题</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%82%E8%80%83-2"><span class="toc-nav-text">参考</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#synchronized"><span class="toc-nav-text">synchronized</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#synchronized%E7%89%B9%E6%80%A7"><span class="toc-nav-text">synchronized特性</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#synchronized%E4%BC%98%E5%8C%96"><span class="toc-nav-text">synchronized优化</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%94%81%E4%BB%8B%E7%BB%8D"><span class="toc-nav-text">锁介绍</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-nav-text">偏向锁</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-nav-text">轻量级锁</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-nav-text">重量级锁</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-nav-text">自旋锁</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%82%E8%80%83-3"><span class="toc-nav-text">参考</span></a></li></ol></li></ol></div><span id="more"></span><h2 id="Java线程池原理分析"><a href="#Java线程池原理分析" class="headerlink" title="Java线程池原理分析"></a>Java线程池原理分析</h2><blockquote><p>2023-01-29</p></blockquote><p>本文主要介绍<code>ThreadPoolExecutor</code></p><h3 id="构造函数的参数"><a href="#构造函数的参数" class="headerlink" title="构造函数的参数"></a>构造函数的参数</h3><h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>核心线程个数</p><h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>最大线程个数</p><ul><li>当线程个数达到<strong>corePoolSize</strong>且<strong>任务队列</strong>满了，会继续创建线程直到线程池内总线程数达到<strong>maximumPoolSize</strong></li><li>对于无限队列，线程数不会多于<strong>corePoolSize</strong></li></ul><h4 id="keepAliveTime，unit"><a href="#keepAliveTime，unit" class="headerlink" title="keepAliveTime，unit"></a>keepAliveTime，unit</h4><p>非核心线程个数超时时间及单位</p><h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h4><p>任务队列</p><h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h4><p>线程工厂。主要用于自定义线程name</p><h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4><p>拒绝策略。当线程数已达最大且任务队列满了触发策略。内置4种拒绝策略，也可以自定义</p><ul><li><code>AbortPolicy</code>：直接抛异常</li><li><code>DiscardPolicy</code>：什么也不做，丢弃任务</li><li><code>DiscardOldestPolicy</code>：移除最早的任务，然后尝试再次执行<code>execute</code>。会校验线程池状态</li><li><code>CallerRunsPolicy</code>：直接在本线程内执行。会校验线程池状态</li><li>自定义：实现接口<code>RejectedExecutionHandler</code></li></ul><h3 id="内部状态ctl字段"><a href="#内部状态ctl字段" class="headerlink" title="内部状态ctl字段"></a>内部状态ctl字段</h3><p>使用32位int保存<strong>线程池状态</strong>(3位)和<strong>线程数</strong>(29位)</p><p>线程池状态有5个：</p><ul><li><code>-1</code>：<code>RUNNING</code>，创建后的状态</li><li><code>0</code>：<code>SHUTDOWN</code>：调用<code>shutdown</code>，不再接受新的任务</li><li><code>1</code>：<code>STOP</code>：调用<code>shutdownNow</code>，丢弃所有任务，中断正在执行的任务</li><li><code>2</code>：<code>TIDYING</code>：工作线程为0，队列为空。即将执行<code>terminated()</code></li><li><code>3</code>：<code>TERMINATED</code>：已终止。在执行<code>terminated()</code> 之后</li></ul><h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 线程数小于corePoolSize，添加核心线程</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果添加失败，说明ctl有变更，核心线程可能满了</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 任务加入队列成功</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 没有运行且从队列中移除成功，触发拒绝策略</span></span><br><span class="line">            <span class="comment">// 移除失败说明已经被worker取走了，已经完成或正在执行，不能触发拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 没有线程，添加非核心线程，但不分配任务，因为任务已经添加到队列</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        <span class="comment">// 队列满了，且添加新线程失败，触发拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><p>从队列里获取下一个任务</p><ul><li>是一个阻塞方法，利用<strong>阻塞队列</strong>实现阻塞</li><li>非核心线程的阻塞时常等于<strong>keepAliveTime</strong>+<strong>unit</strong>，超时后返回<code>null</code></li><li>核心线程一直阻塞(有开关<code>allowCoreThreadTimeOut</code>)</li></ul><h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><ul><li>属于线程池方法</li><li>while循环调用<code>getTask</code>方法获取任务并执行，如果任务为<code>null</code>，worker退出</li><li>任务抛出异常则worker退出</li><li>退出时会调用<code>tryTerminate</code></li><li>worker退出时，<strong>任务发生异常</strong>或<strong>线程数小于核心线程数</strong>，则会尝试新建一个非核心线程</li></ul><h3 id="submit方法"><a href="#submit方法" class="headerlink" title="submit方法"></a>submit方法</h3><p><code>execute</code>的参数是<code>Runnable</code>，<code>Runnable</code>并没有返回值，无法直接获取执行的结果，而<code>submit</code>的参数<code>Callable</code>是有返回值的，<code>submit</code>返回<code>Future</code>，包含<code>Callable</code>的返回值</p><ul><li><code>submit</code>方法执行发生异常不会输出到控制台</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单，将<code>Callable&lt;T&gt;</code>包装成<code>Runnable</code>传给<code>execute</code>，而<code>newTaskFor</code>就是新建一个<code>FutureTask</code></p><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><ul><li>在<code>run</code>函数内调用<code>call</code>函数，使用<code>outcome</code>字段保存结果或者异常</li><li>调用<code>get</code>时，校验状态，抛出异常或者返回结果</li></ul><h2 id="阻塞队列和AQS"><a href="#阻塞队列和AQS" class="headerlink" title="阻塞队列和AQS"></a>阻塞队列和AQS</h2><p>以下以<code>LinkedBlockingQueue</code>为例</p><h3 id="offer方法，阻塞添加"><a href="#offer方法，阻塞添加" class="headerlink" title="offer方法，阻塞添加"></a>offer方法，阻塞添加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout); <span class="comment">// 计算阻塞纳秒数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取put锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">// 当前队列满了</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 说明等待超时，意味着添加失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 需等待，并且释放put锁，其他线程调用offer也会停在这里</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">            <span class="comment">// nanos = nanos - 等待的时间</span></span><br><span class="line">            <span class="comment">// 走到这里，重新获取了put锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement(); <span class="comment">// c是添加前的队列大小</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            <span class="comment">// 添加后队列依然不满，其他offer线程发信号继续执行</span></span><br><span class="line">            <span class="comment">// 如果没有下面这句话，其他offer线程会等到超时才会继续执行</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放put锁</span></span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 添加前队列为空，可能存在其他获取线程阻塞，这里通知他们可以取了</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 添加成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="poll方法，阻塞获取"><a href="#poll方法，阻塞获取" class="headerlink" title="poll方法，阻塞获取"></a>poll方法，阻塞获取</h3><p>流程和上述差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout); <span class="comment">// 计算阻塞纳秒数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取take锁</span></span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 超时返回null，说明阻塞队列值不能有null</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement(); <span class="comment">// c是取走前的队列大小</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 取走后还有剩余，则通知其他获取线程执行</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">// 取之前是满的，则通知其他添加线程执行</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h3><blockquote><p>以<code>LinkedBlockingQueue</code>为例，其内部使用<code>ReentrantLock</code></p></blockquote><h3 id="AQS（AbstractQueuedSynchronizer，抽象队列同步器）"><a href="#AQS（AbstractQueuedSynchronizer，抽象队列同步器）" class="headerlink" title="AQS（AbstractQueuedSynchronizer，抽象队列同步器）"></a>AQS（AbstractQueuedSynchronizer，抽象队列同步器）</h3><p>一个AQS包含一个同步队列和多个条件队列。在条件队列等待的线程需等待对应条件的<code>signal</code>信号，然后加入到同步队列</p><p>如果当前队列如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync Queue: 1 --&gt; 2 --&gt; 3</span><br><span class="line">Condition A Queue: 4 --&gt; 5 --&gt; 6</span><br><span class="line">Condition B Queue: 7 --&gt; 8 --&gt; 9</span><br></pre></td></tr></table></figure><p>触发一次<code>A.signal()</code>，结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync Queue: 1 --&gt; 2 --&gt; 3 --&gt; 4</span><br><span class="line">Condition A Queue: 5 --&gt; 6</span><br><span class="line">Condition B Queue: 7 --&gt; 8 --&gt; 9</span><br></pre></td></tr></table></figure><p>源码解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123; <span class="comment">// 节点定义</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步队列，链表表头</span></span><br><span class="line">    Node head; </span><br><span class="line">    Node tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条件对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter; <span class="comment">// 条件队列，链表表头</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// ...其他代码</span></span><br><span class="line">            <span class="comment">// 将条件队列的第一个等待者加入同步队列</span></span><br><span class="line">            enq(firstWaiter)</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 添加一个条件Waiter</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">            <span class="comment">// 循环判断是否在同步队列，如果不在就继续挂起</span></span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在同步队列尝试获取锁，内部依然是循环</span></span><br><span class="line">            acquireQueued(node, savedState)</span><br><span class="line">            <span class="comment">// ...其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 将node添加至同步队列末尾</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Unsafe-park-absolute-time"><a href="#Unsafe-park-absolute-time" class="headerlink" title="Unsafe.park(absolute, time)"></a>Unsafe.park(absolute, time)</h4><p>挂起当前线程</p><ul><li>absolute：是否是绝对时间。若为true，则time是具体毫秒数时间戳；若为false，则time是挂起的纳秒数</li></ul><h4 id="Unsafe-unpark-thread"><a href="#Unsafe-unpark-thread" class="headerlink" title="Unsafe.unpark(thread)"></a>Unsafe.unpark(thread)</h4><p>恢复挂起线程</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://blog.csdn.net/a7980718/article/details/83661613">https://blog.csdn.net/a7980718/article/details/83661613</a></li></ol><h2 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h2><blockquote><p>2023-03-14</p></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当并行从有多个数据源同时取数据时，我们可能会写出以下代码，先提交任务再循环<code>get</code>，使用异常进行逻辑判断，很不优雅</p><h4 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">TIMEOUT</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">TASK_NUM</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Future&lt;String&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TASK_NUM; i++) &#123;</span><br><span class="line">    Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">    futures.add(future);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (Future&lt;String&gt; future : futures) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> TIMEOUT - (System.currentTimeMillis() - start);</span><br><span class="line">    <span class="keyword">if</span> (time &gt; <span class="number">0</span> || future.isDone()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> future.get(time, TimeUnit.MILLISECONDS);</span><br><span class="line">            res.add(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        future.cancel(<span class="literal">true</span>); <span class="comment">// 中断超时线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果使用CompletionService"><a href="#如果使用CompletionService" class="headerlink" title="如果使用CompletionService"></a>如果使用<code>CompletionService</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CompletionService&lt;String&gt; completionService = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;&gt;(executor);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TASK_NUM; i++) &#123;</span><br><span class="line">    completionService.submit(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">start2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> TIMEOUT - (System.currentTimeMillis() - start2);</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    Future&lt;String&gt; future = completionService.poll(time, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (future == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">// future为null说明超时</span></span><br><span class="line">    res.add(f.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CompletionService原理"><a href="#CompletionService原理" class="headerlink" title="CompletionService原理"></a><code>CompletionService</code>原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">QueueingFuture</span> <span class="keyword">extends</span> <span class="title class_">FutureTask</span>&lt;Void&gt; &#123;</span><br><span class="line">    QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">        <span class="built_in">super</span>(task, <span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">()</span> &#123; completionQueue.add(task); &#125; <span class="comment">// 完成时加入到完成队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他使用场景"><a href="#其他使用场景" class="headerlink" title="其他使用场景"></a>其他使用场景</h3><h4 id="取出第一个完成的结果"><a href="#取出第一个完成的结果" class="headerlink" title="取出第一个完成的结果"></a>取出第一个完成的结果</h4><ul><li>没有超时</li><li>不中断其他线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TASK_NUM; i++) &#123;</span><br><span class="line">    completionService.submit(callable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> completionService.take().get();</span><br><span class="line"><span class="comment">// use result</span></span><br></pre></td></tr></table></figure><h4 id="限时内取出第一个非null的结果"><a href="#限时内取出第一个非null的结果" class="headerlink" title="限时内取出第一个非null的结果"></a>限时内取出第一个非null的结果</h4><ul><li>有超时</li><li>中断其他线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Future&lt;String&gt;&gt; futures4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(TASK_NUM); <span class="comment">// 用于中断</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TASK_NUM; i++) &#123;</span><br><span class="line">    futures4.add(completionService.submit(callable));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">start4</span> <span class="operator">=</span> System.currentTimeMillis(); <span class="comment">// 计时</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result4</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TASK_NUM; i++) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> TIMEOUT - (System.currentTimeMillis() - start4);</span><br><span class="line">    <span class="keyword">if</span> (time &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    Future&lt;String&gt; future = completionService.poll(time, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (future == <span class="literal">null</span>) <span class="keyword">break</span>; <span class="comment">// future为null说明超时，直接退出</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> future.get();</span><br><span class="line">    <span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">        result4 = data;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Future&lt;String&gt; future : futures4) &#123;</span><br><span class="line">    future.cancel(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result4 != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// use result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentHashMap原理"><a href="#ConcurrentHashMap原理" class="headerlink" title="ConcurrentHashMap原理"></a>ConcurrentHashMap原理</h2><blockquote><p>2023-04-19<br>基于Java 8</p></blockquote><h3 id="初始化Table"><a href="#初始化Table" class="headerlink" title="初始化Table"></a>初始化Table</h3><ul><li>线程安全保证：cas</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h3><p>流程：</p><ul><li>如果直接在table上，直接返回</li><li>如果eh &lt; 0，执行该节点的<code>find</code>方法<ul><li><code>eh=-1</code>：<code>MOVED</code>：在扩容中</li><li><code>eh=-2</code>：<code>TREEBIN</code>：作为红黑树的根节点</li><li><code>eh=-3</code>：<code>RESERVED</code>：占位Node</li></ul></li><li>除此之外就是链表，直接遍历链表</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h4 id="find方法"><a href="#find方法" class="headerlink" title="find方法"></a>find方法</h4><ul><li><code>Node</code>：链表遍历查询</li><li><code>ForwardingNode</code>：迁移过程中，查询新节点</li><li><code>TreeBin</code>：红黑树根节点查询，包括<code>TreeNode</code></li><li><code>ReservationNode</code>：用于占位的Node，始终返回<code>null</code>，用于<code>compute</code>和<code>computeIfAbsent</code></li></ul><h3 id="Put方法"><a href="#Put方法" class="headerlink" title="Put方法"></a>Put方法</h3><p>流程：</p><ul><li>如果table没有初始化，则先初始化</li><li>如果新节点对应的桶为空，则通过cas设置，成功则返回</li><li>如果对应的桶的hash是<code>MOVED</code>，说明在扩容中，则先帮助扩容</li><li>将桶作为<strong>同步对象</strong><ul><li><code>fh &gt;= 0</code>说明是链表，直接在链表<strong>尾部</strong>添加</li><li>如果是红黑树，则插入</li></ul></li><li>如果链表的操作数大于等于8，则转为红黑树</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他修改方法和<code>put</code>方法结构类似</li></ul><h3 id="transfer扩容"><a href="#transfer扩容" class="headerlink" title="transfer扩容"></a>transfer扩容</h3><p>桶的个数<code>n</code>是2次幂的，桶定位方式是<code>i = (n - 1) &amp; h)</code>，当扩容为2倍时，如果<code>n &amp; h == 0</code>，则桶号保持不变，如果<code>n &amp; h == n</code>，则桶号为<code>i + n</code></p><ul><li>初始化<code>nextTab</code>，大小为原来的两倍</li><li>根据CPU个数选出每次循环处理的批次，最少16，从右往左处理依次处理<ul><li>如果<code>tab[i] == null</code>，则通过cas设置旧table的<code>tab[i]</code>为fwd</li><li>如果是链表或者红黑树，则拆成2条链或树。如果红黑树个数很少，会退化为链表。通过cas设置旧table的<code>tab[i]</code>为fwd，新table的两个桶为新的<code>Node</code>或<code>TreeBin</code>节点</li></ul></li></ul><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://juejin.cn/post/6844903758690779149">java并发之ConcurrentHashMap 1.8原理详解</a></li></ul><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><blockquote><p>2023-04-06<br>Java 8引入了函数式编程，大大提高代码的可读性，写起来也更优雅。异步编程自然也不例外，新增的<code>CompletableFuture</code>就是为了使用函数式编程来更优雅地编写异步代码</p></blockquote><h3 id="构造CompletableFuture"><a href="#构造CompletableFuture" class="headerlink" title="构造CompletableFuture"></a>构造CompletableFuture</h3><p>一般直接使用工厂方法创建</p><ul><li><code>completedFuture(value)</code>：直接构造一个已经完成的<code>CompletableFuture</code></li><li><code>supplyAsync(Supplier&lt;U&gt;,Executor)</code>：如果第二个参数不传，则使用默认的<code>ForkJoinPool</code>，不建议如此做</li><li><code>runAsync(Runnable,Executor)</code>：和<code>supplyAsync</code>类似，无返回值版本</li></ul><h3 id="链式调用（异步顺序执行）"><a href="#链式调用（异步顺序执行）" class="headerlink" title="链式调用（异步顺序执行）"></a>链式调用（异步顺序执行）</h3><p>大多数链式调用都有异步版本（<code>Async</code>结尾），会多一个Executor参数，如果不传会使用<code>ForkJoinPool</code></p><ul><li><code>thenApply(Function&lt;T,U&gt;)</code>：在上一段代码完成后执行，接受上一段代码的结果<code>T</code>，并生成新的结果<code>U</code>，返回<code>CompletableFuture&lt;U&gt;</code><ul><li>有异步版本</li><li><code>AND</code>合并版本：<code>thenCombine(other,BiFunction&lt;T,U,V&gt;)</code></li><li><code>OR</code>合并版本：<code>applyToEither(other,Function&lt;T,V&gt;)</code></li></ul></li><li><code>thenAccept(Consumer&lt;T&gt;)</code>：在上一段代码完成后执行，接受上一段代码的结果<code>T</code>，返回<code>CompletableFuture&lt;Void&gt;</code><ul><li>有异步版本</li><li><code>AND</code>合并版本：<code>thenAcceptBoth(other,BiConsumer&lt;T,U&gt;)</code></li><li><code>OR</code>合并版本：<code>acceptEither(other,Consumer&lt;T&gt;)</code></li></ul></li><li><code>thenRun(Runnable)</code>：在上一段代码完成后执行，返回<code>CompletableFuture&lt;Void&gt;</code><ul><li>有异步版本</li><li><code>AND</code>合并版本：<code>runAfterBoth(other,Runnable)</code></li><li><code>OR</code>合并版本：<code>runAfterEither(other,Runnable)</code></li></ul></li><li><code>thenCompose(Function&lt;T,CompletionStage&lt;U&gt;&gt;)</code>：和<code>thenApply</code>不同，直接返回<code>CompletableFuture&lt;U&gt;</code><ul><li>有异步版本</li></ul></li><li><code>handle(BiFunction)</code>：同时处理结果和异常<ul><li>有异步版本</li></ul></li><li><code>whenComplete(BiConsumer)</code>：<code>handle</code>的无返回值版本<ul><li>有异步版本</li></ul></li><li><code>exceptionally(Function)</code>：链式（不仅是前一个）发生异常时执行，一次异常仅触发一次</li></ul><h3 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h3><ul><li><code>CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)</code>：等待cfs全部结束</li><li><code>CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)</code>：等待cfs其中一个结束</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><h4 id="同步操作的线程问题"><a href="#同步操作的线程问题" class="headerlink" title="同步操作的线程问题"></a>同步操作的线程问题</h4><ul><li>如果前一个异步代码段<strong>有阻塞操作</strong>，则后续同步操作的线程和前面的异步线程相同，否则会在<strong>当前线程</strong></li></ul><p>没有阻塞操作时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;data&quot;</span>;</span><br><span class="line">        &#125;, executor)</span><br><span class="line">        .thenRun(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure><p>输出：（同步操作在<strong>当前线程</strong>执行）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line">main</span><br></pre></td></tr></table></figure><p>添加阻塞操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123; <span class="comment">// 模拟阻塞操作</span></span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;data&quot;</span>;</span><br><span class="line">        &#125;, executor)</span><br><span class="line">        .thenRun(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure><p>输出：（同步操作和<strong>异步线程</strong>线程一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br></pre></td></tr></table></figure><ul><li>提示<code>System.out.format</code>第一次执行时存在阻塞操作，而<code>System.out.println</code>没有</li></ul><h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://juejin.cn/post/6970558076642394142">https://juejin.cn/post/6970558076642394142</a></li><li><a href="https://quanhuynh.dev/thread-handling-in-java-completablefuture/">https://quanhuynh.dev/thread-handling-in-java-completablefuture/</a></li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><blockquote><p>2023-04-20</p></blockquote><h3 id="synchronized特性"><a href="#synchronized特性" class="headerlink" title="synchronized特性"></a>synchronized特性</h3><ul><li>乐观锁，如果频繁，则转为悲观锁</li><li>普通互斥锁，非公平锁、可重入锁</li><li>轻量级锁（自旋锁），如果锁被持有的时间较长，则转换为重量级锁（挂起等待）</li></ul><h3 id="synchronized优化"><a href="#synchronized优化" class="headerlink" title="synchronized优化"></a>synchronized优化</h3><ul><li>1.6之前是重量级锁</li><li><strong>锁升级（膨胀）机制</strong>：无锁升级到偏向锁，再到轻量级锁，最后到重量级锁的过程</li><li><strong>锁消除</strong>，根据逃逸分析，对锁进行消除</li><li><strong>锁粗化</strong>，减少加锁解锁次数</li><li><strong>自适应自旋锁</strong>，线程自旋的次数不再是固定的值，而是一个动态改变的值，这个值会根据前一次自旋获取锁的状态来决定此次自旋的次数</li></ul><h3 id="锁介绍"><a href="#锁介绍" class="headerlink" title="锁介绍"></a>锁介绍</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>在运行过程中，对象的锁偏向某个线程。即在开启偏向锁机制的情况下，某个线程获得锁，当该线程下次再想要获得锁时，不需要再获得锁（即忽略<code>synchronized</code>关键词），直接就可以执行同步代码，比较适合竞争较少的情况</p><ul><li>线程不会主动去释放偏向锁</li><li>偏向锁的撤销需要等待全局安全点（即没有字节码正在执行），它会暂停拥有偏向锁的线程，撤销后偏向锁恢复到未锁定状态或轻量级锁状态</li><li>如果有竞争，则升级为<strong>轻量级锁</strong></li><li>since 1.6</li><li>JDK 15开始默认关闭</li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>对于没有多线程竞争的情况，如果存在多线程竞争，则膨胀为<strong>重量级锁</strong></p><ul><li>since 1.6</li></ul><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>即当有其他线程占用锁时，当前线程会进入阻塞状态</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>在自旋状态下，当一个线程A尝试进入同步代码块，但是当前的锁已经被线程B占有时，线程A不进入阻塞状态，而是不停的空转，等待线程B释放锁。<strong>如果锁的线程能在很短时间内释放资源，那么等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，只需自旋，等持有锁的线程释放后即可立即获取锁，避免了用户线程和内核的切换消耗。</strong></p><p><strong>自旋等待最大时间</strong>：线程自旋会消耗cpu，若自旋太久，则会让cpu做太多无用功，因此要设置自旋等待最大时间。</p><p><strong>优点</strong>：开启自旋锁后能减少线程的阻塞，在对于锁的竞争不激烈且占用锁时间很短的代码块来说，能提升很大的性能，在这种情况下自旋的消耗小于线程阻塞挂起的消耗</p><p><strong>缺点</strong>：在线程竞争锁激烈，或持有锁的线程需要长时间执行同步代码块的情况下，使用自旋会使得cpu做的无用功太多</p><h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://cloud.tencent.com/developer/article/1447345">偏向锁、轻量级锁、重量级锁、自旋锁原理讲解</a></li><li><a href="https://juejin.cn/post/7164749887464456222">synchronized的优化机制和一些多线程的常见类</a></li><li><a href="https://blog.csdn.net/qicha3705/article/details/120494362">Synchronized原理（轻量级锁篇）</a></li><li><a href="https://juejin.cn/post/7046921350065160206">难搞的偏向锁终于被 Java 移除了</a></li><li><a href="https://blog.csdn.net/java_dazhuzhu/article/details/119574987">synchronized 中的 4 个优化，你知道几个？</a></li><li><a href="https://juejin.cn/post/6991850044462727199">synchronized 优化手段之锁膨胀机制｜ 8月更文挑战</a></li></ul><div style="border-top:2px solid #eee;height:1px;margin:8px 0"></div><div class="article-category"><svg class="i-tag" width="16px" height="16px" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M5.41959 3.23866C6.23018 3.05852 7.19557 3 8.312 3H9.92963C10.9327 3 11.8694 3.5013 12.4258 4.3359L13.2383 5.5547C13.4238 5.83288 13.736 6 14.0704 6H19.1258C20.7233 6 22.0181 7.26115 22.0029 8.8852C21.9847 10.8192 22 12.7539 22 14.688C22 15.8044 21.9415 16.7698 21.7613 17.5804C21.5787 18.4024 21.2579 19.1251 20.6915 19.6915C20.1251 20.2579 19.4024 20.5787 18.5804 20.7613C17.7698 20.9415 16.8044 21 15.688 21H8.312C7.19557 21 6.23018 20.9415 5.41959 20.7613C4.59764 20.5787 3.87488 20.2579 3.30848 19.6915C2.74209 19.1251 2.42133 18.4024 2.23866 17.5804C2.05852 16.7698 2 15.8044 2 14.688V9.312C2 8.19557 2.05852 7.23018 2.23866 6.41959C2.42133 5.59764 2.74209 4.87488 3.30848 4.30848C3.87488 3.74209 4.59764 3.42133 5.41959 3.23866ZM8.19103 13.8535C8.05868 14.449 8 15.2412 8 16.312V18C8 18.5523 7.55228 19 7 19C6.44772 19 6 18.5523 6 18V16.312C6 15.1956 6.05852 14.2302 6.23866 13.4196C6.42133 12.5976 6.74209 11.8749 7.30848 11.3085C7.87488 10.7421 8.59764 10.4213 9.41959 10.2387C10.2302 10.0585 11.1956 10 12.312 10H17.688H19C19.5523 10 20 10.4477 20 11C20 11.5523 19.5523 12 19 12H17.688H12.312C11.2412 12 10.449 12.0587 9.85349 12.191C9.26933 12.3209 8.9375 12.5079 8.72269 12.7227C8.50789 12.9375 8.32085 13.2693 8.19103 13.8535Z"/></svg> &nbsp; <a class="article-category-link" href="/category/technology/">技术</a>&nbsp;/&nbsp;<a class="article-category-link" href="/category/technology/java/">Java</a></div><div class="article-tag"><svg class="i-tag" width="16" height="16" viewBox="0 0 24 24" fill="currentcolor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.678 11.422a2.5 2.5 0 0 0 0 3.536l6.364 6.364a2.5 2.5 0 0 0 3.536 0l7.69-7.69A2.5 2.5 0 0 0 21 11.864V4.5A1.5 1.5 0 0 0 19.5 3h-7.365a2.5 2.5 0 0 0-1.768.732l-7.69 7.69zM14.988 7C13.878 7 13 7.832 13 8.988c0 1.157.878 2.012 1.988 2.012C16.121 11 17 10.145 17 8.988 17 7.832 16.12 7 14.988 7z"/></svg> &nbsp; <a class="article-tag-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a>, <a class="article-tag-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></div><div class="article-date"><time datetime="2023-01-29T05:00:00.000Z" itemprop="datePublished">2023-01-29</time></div></article></body></html>