<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿·ä½ é—®é“</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --second-color: #888;
            --accent-color: #4caf50;
            --danger-color: #f44336;
            --highlight-color: #ffeb3b;
            --border-color: #333;
            --panel-bg: #2d2d2d;
            --npc-color: #9c27b0;
            --item-heal-color: #43a047;
            --item-eq-color: #43a047;
            --quality-blue-color: #7f7fff;
            --quality-gold-color: #ffff00;
            --quality-pink-color: #ff00ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            width: 100%;
            max-width: 1200px;
            height: 95vh;
            display: flex;
            gap: 20px;
            background-color: var(--panel-bg);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
        }

        #game-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow: hidden;
            min-width: 0;
            position: relative;
        }

        #log-container {
            width: 350px;
            display: flex;
            flex-direction: column;
            background-color: var(--border-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            overflow: hidden;
        }

        header {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 15px;
            margin-bottom: 15px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            background-color: #222;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .stat-label {
            color: var(--second-color);
        }

        .stat-value {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--highlight-color);
        }


        .stat-item.highlight {
            animation: statPulse 0.5s ease;
        }

        @keyframes statPulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow: hidden;
            min-width: 0;
        }

        #log-section {
            flex: 1;
            overflow-y: auto;
        }

        .log-entry {
            animation: fadeIn 0.3s ease;
        }

        .log-entry.player-action {
            color: #81d4fa;
        }

        .log-entry.enemy-action {
            color: #ef9a9a;
        }

        .log-entry.system {
            color: white;
        }

        .log-entry.critical {
            color: var(--highlight-color);
        }

        .log-entry.death {
            color: var(--danger-color);
        }

        .log-entry.legendary {
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        button {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 15px;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        button:active:not(:disabled) {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: #000;
        }

        button.danger {
            border-color: var(--danger-color);
            color: var(--danger-color);
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background-color: #333;
            margin-top: 8px;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #444;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--accent-color);

            transition: width 0.3s ease;
        }

        .hp-fill {
            background: linear-gradient(90deg, #f44336, #e53935);
        }

        .exp-fill {
            background: linear-gradient(90deg, #ffeb3b, #ffc107);
        }

        /* æ¨¡æ€æ¡†é€šç”¨æ ·å¼ */
        .game-over-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .game-over-modal-content {
            background: var(--panel-bg);
            padding: 30px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            text-align: center;
            max-width: 400px;
        }

        .game-over-modal-title {
            font-size: 2rem;
            margin-bottom: 20px;
        }

        /* æˆ˜æ–—æ¨¡æ€æ¡† */
        #battle-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .battle-modal-content {
            background: var(--panel-bg);
            padding: 15px;
            /* border: 3px solid var(--danger-color); */
            border-radius: 12px;
            text-align: center;
            max-width: 600px;
            width: 90%;
        }

        .battle-compare-section {
            display: flex;
            gap: 15px;
        }

        .battle-side {
            flex: 1;
            background-color: #222;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #444;
        }

        .battle-sid e.enemy-side {
            border-color: var(--danger-color);
        }

        .battle-side-title {
            font-size: 1.4rem;
            margin-bottom: 15px;
            font-weight: bold;
        }

        .battle-side.player-side .battle-side-title {
            color: var(--accent-color);
        }

        .battle-side.enemy-side .battle-side-title {
            color: var(--danger-color);
        }

        .battle-side.enemy-side .battle-side-title.gold-enemy {
            color: #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
        }

        .battle-stat-row {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding: 10px;
            background-color: #333;
            border-radius: 6px;
        }


        .battle-stat-label {
            font-size: 0.9rem;
            color: #888;
        }

        .battle-stat-value {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .battle-hp-bar {
            width: 100%;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 8px;
            border: 1px solid #444;
        }

        .battle-hp-fill {
            height: 100%;
            transition: width 0.3s ease;
        }

        .battle-hp-fill.player {
            background: linear-gradient(90deg, #4caf50, #43a047);
        }

        .battle-hp-fill.enemy {
            background: linear-gradient(90deg, #f44336, #e53935);
        }

        .battle-actions {
            margin-top: 20px;
        }

        .battle-action-btn {
            border-radius: 8px;
        }

        .battle-action-btn.attack {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: #000;
        }

        .battle-action-btn.flee {
            background-color: #333;
            border-color: var(--danger-color);
            color: var(--danger-color);
        }

        .battle-status {
            margin: 15px;
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            color: var(--danger-color);
        }

        /* åœ°å›¾ç³»ç»Ÿæ ·å¼ */
        #map-section,
        #npc-section {
            background-color: #222;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid var(--border-color);
        }

        #map-title,
        #npc-title {
            color: var(--highlight-color);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #npc-title {
            color: var(--npc-color);
        }

        #map-buttons,
        #npc-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .map-button {
            background-color: #333;
            color: #aaa;
            border: 1px solid #555;
            padding: 8px 15px;
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .map-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }


        .map-button.unlocked {
            background-color: rgba(76, 175, 80, 0.2);
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        .map-button.current {
            background-color: rgba(255, 235, 59, 0.2);
            border-color: var(--highlight-color);
            color: var(--highlight-color);
        }

        /* NPCç³»ç»Ÿæ ·å¼ */
        .npc-card {
            background-color: #333;
            border: 2px solid #555;
            padding: 12px 18px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .npc-info {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .npc-name {
            color: #fff;
        }

        .no-npc {
            color: #666;
            font-style: italic;
            padding: 10px;
        }

        /* NPCå¯¹è¯æ¨¡æ€æ¡† */
        #npc-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 150;
        }

        .npc-modal-content {
            background: var(--panel-bg);
            padding: 30px;
            border: 3px solid var(--npc-color);
            border-radius: 12px;
            text-align: center;
            max-width: 500px;
            width: 90%;
        }

        .npc-modal-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #333;
        }

        .npc-modal-icon {
            font-size: 2rem;
        }

        .npc-modal-name {
            font-size: 2rem;
            font-weight: bold;
            color: var(--npc-color);
        }

        .npc-dialogue {
            background-color: #222;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #444;
            margin-bottom: 20px;
            font-size: 1rem;
            line-height: 1.6;
            min-height: 80px;
            display: flex;
            align-items: center;

            justify-content: center;
        }

        .npc-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .npc-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .npc-action-btn.heal {
            background: linear-gradient(135deg, #4caf50, #43a047);
            border-color: #4caf50;
        }

        .npc-close-btn {
            background-color: #333;
            /* border: 2px solid #555; */
            margin-top: 20px;
        }

        /* èƒŒåŒ…ç³»ç»Ÿæ ·å¼ */
        #inventory-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 160;
        }

        .inventory-modal-content {
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 15px;
            border-bottom: 2px solid #333;
        }

        .inventory-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ff9800;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .inventory-item {
            background-color: #222;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .inventory-item-base {
            display: flex;
            flex-direction: column;

            align-items: center;
            gap: 8px;
        }

        .inventory-item:hover {
            border-color: #ff9800;
            background-color: #2a2a2a;
        }

        .inventory-item.heal:hover {
            border-color: #ff9800;
            background-color: #2a2a2a;
        }

        .inventory-item-icon {
            font-size: 2.5rem;
        }

        .inventory-item-name {
            font-size: 0.9rem;
            font-weight: bold;
        }

        .inventory-item-count {
            font-size: 0.8rem;
            color: #ff9800;
            background-color: rgba(255, 152, 0, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
        }

        .inventory-item-description {
            color: #888;
            text-align: center;
        }

        .inventory-item-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
        }

        .inventory-item-btn {
            flex: 1;
            padding: 8px;
            font-size: 0.8rem;
            border-radius: 4px;
        }

        .inventory-item-btn.use {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: #000;
        }

        .inventory-item-btn.use:hover:not(:disabled) {
            background-color: #43a047;
        }

        .inventory-item-btn.equip {
            background-color: #ff9800;
            border-color: #ff9800;
            color: #000;
        }

        .inventory-item-btn.equip:hover:not(:disabled) {
            background-color: #f57c00;
        }

        .inventory-item-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .empty-inventory {
            color: #666;
            font-style: italic;
            padding: 30px;
            font-size: 1rem;
        }

        .inventory-close-btn {
            background-color: #333;
            border: 2px solid #555;
            color: #aaa;
            padding: 12px 30px;
            font-size: 1rem;
        }

        .inventory-close-btn:hover:not(:disabled) {
            background-color: #444;
            color: #fff;
        }

        /* è£…å¤‡æ§½æ ·å¼ */
        .equipment-section {
            background-color: #222;
            border: 2px solid #ff9800;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .equipment-title {
            font-size: 1rem;
            font-weight: bold;
            color: #ff9800;
            margin-bottom: 10px;
        }

        .weapon-slot {
            background-color: #333;
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 15px;
            min-height: 80px;
            display: flex;
            align-items: center;

            justify-content: center;
            transition: all 0.3s ease;
        }

        .weapon-slot.has-weapon {
            border-style: solid;
            border-color: #ff9800;
            background-color: rgba(255, 152, 0, 0.1);
        }

        .empty-slot {
            color: #666;
            font-style: italic;
            font-size: 1rem;
        }

        .equipped-weapon {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #fff;
        }

        .equipped-weapon-icon {
            font-size: 3rem;
        }

        .equipped-weapon-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .equipped-weapon-name {
            margin-bottom: 8px;
        }

        .equipped-weapon-bonus-base {
            color: var(--text-color);
        }

        .quality-blue {
            color: var(--quality-blue-color);
            border-color: var(--quality-blue-color);
        }

        .quality-gold {
            color: #ffff00;
            border-color: #ffff00;
        }

        .unequip-btn {
            background-color: #f44336;
            border: 1px solid #f44336;
            color: white;
            padding: 5px 10px;
            font-size: 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }

        .unequip-btn:hover {
            background-color: #d32f2f;
        }

        /* æ—¥å¿—åŒºåŸŸæ ‡é¢˜æ  */
        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background-color: #2a2a2a;
            border-bottom: 1px solid var(--border-color);
        }

        .log-title,
        .clear-log-btn {
            color: var(--second-color);
        }

        .clear-log-btn {
            padding-top: 10px;
            padding-bottom: 10px;
        }

        /* æŸ¥çœ‹æ—¥å¿—æŒ‰é’®ï¼ˆç§»åŠ¨ç«¯ï¼‰ */
        #btn-show-log {
            display: none;
        }

        /* å…³é—­æ—¥å¿—æŒ‰é’®ï¼ˆç§»åŠ¨ç«¯ï¼‰ */
        #btn-close-log {
            display: none;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 900px) {
            #game-container {
                flex-direction: column;
                height: 100vh;
                border-radius: 0;
            }

            header {
                gap: 5px;
                padding-bottom: 10px;
                margin-bottom: 10px;
            }

            /* æ—¥å¿—å®¹å™¨é»˜è®¤éšè— */
            #log-container {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 300;

                background-color: rgba(0, 0, 0, 0.95);
            }

            /* æ—¥å¿—å®¹å™¨æ˜¾ç¤ºæ—¶ */
            #log-container.show {
                display: flex;
            }

            /* æŸ¥çœ‹æ—¥å¿—æŒ‰é’® */
            #btn-show-log {
                display: block !important;
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 60px;
                height: 60px;
                border-radius: 50%;
                padding: 10px;
                z-index: 250;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
                background: linear-gradient(135deg, #4caf50, #43a047);
                border: none;
            }

            /* å…³é—­æ—¥å¿—æŒ‰é’® */
            #btn-close-log {
                display: block !important;
            }
        }
    </style>
</head>

<body>

    <div id="game-container">
        <!-- å·¦ä¾§æ¸¸æˆåŒºåŸŸ -->
        <div id="game-main">
            <!-- å¤´éƒ¨ï¼šç©å®¶çŠ¶æ€ -->
            <header>
                <div class="stat-item">
                    <span class="stat-label">â¤ï¸ ç”Ÿå‘½å€¼<span class="stat-value" id="player-hp">100/100</span></span>
                    <div class="progress-bar">
                        <div class="progress-fill hp-fill" id="hp-bar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-label">âš”ï¸ æ”»å‡»åŠ›</span>
                    <span class="stat-value" id="player-atk" style="color: #ff5722;">10</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">â­ ç­‰çº§: <span class="stat-value" id="player-lv">1</span></span>
                    <span class="stat-value" id="player-exp">0%</span>
                    <div class="progress-bar">
                        <div class="progress-fill exp-fill" id="exp-bar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ğŸ’° é‡‘å¸</span>
                    <span class="stat-value" id="player-gold" style="color: #ffd700;">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ğŸ¯ æš´å‡»ç‡</span>
                    <span class="stat-value" id="player-crit" style="color: #ff9800;">10%</span>
                </div>
                <div class="stat-item">
                    <button class="primary" id="btn-inventory" style="width: 100%; margin-top: auto;">
                        ğŸ’ èƒŒåŒ…
                    </button>
                </div>
            </header>

            <main>
                <!-- åœ°å›¾ç³»ç»Ÿ -->
                <section id="map-section">
                    <div id="map-title">

                        <span>ğŸ“ å½“å‰ä½ç½®ï¼š<span id="current-map-name">æ‘åº„</span></span>
                    </div>
                    <div id="map-buttons">
                    </div>
                </section>

                <!-- NPCç³»ç»Ÿ -->
                <section id="npc-section">
                    <div id="npc-title">
                        <span>ğŸ‘¥ NPCåˆ—è¡¨</span>
                    </div>
                    <div id="npc-list">
                    </div>
                </section>
            </main>

            <!-- æˆ˜æ–—æ¨¡æ€æ¡† -->
            <div id="battle-modal">
                <div class="battle-modal-content">
                    <div class="battle-status" id="battle-status">æˆ˜æ–—è¿›è¡Œä¸­...</div>
                    <div class="battle-compare-section">
                        <div class="battle-side player-side">

                            <div class="battle-side-title">ğŸ‘¤ ç©å®¶</div>
                            <div class="battle-stat-row">
                                <span class="battle-stat-label">â¤ï¸ ç”Ÿå‘½å€¼</span>
                                <span class="battle-stat-value" id="battle-player-hp">100/100</span>
                            </div>
                            <div class="battle-hp-bar">
                                <div class="battle-hp-fill player" id="battle-player-hp-fill" style="width: 100%"></div>
                            </div>
                            <div class="battle-stat-row" style="margin-top: 15px;">
                                <span class="battle-stat-label">âš”ï¸ æ”»å‡»åŠ›</span>
                                <span class="battle-stat-value" id="battle-player-atk">10</span>
                            </div>
                            <div class="battle-stat-row">
                                <span class="battle-stat-label">ğŸ¯ æš´å‡»ç‡</span>
                                <span class="battle-stat-value" id="battle-player-crit">10%</span>
                            </div>
                        </div>
                        <div class="battle-side enemy-side">
                            <div class="battle-side-title" id="battle-enemy-name">ğŸ‘¹ ???</div>
                            <div class="battle-stat-row">
                                <span class="battle-stat-label">â¤ï¸ ç”Ÿå‘½å€¼</span>
                                <span class="battle-stat-value" id="battle-enemy-hp">100/100</span>
                            </div>
                            <div class="battle-hp-bar">
                                <div class="battle-hp-fill enemy" id="battle-enemy-hp-fill" style="width: 100%"></div>
                            </div>
                            <div class="battle-stat-row" style="margin-top: 15px;">
                                <span class="battle-stat-label">âš”ï¸ æ”»å‡»åŠ›</span>
                                <span class="battle-stat-value" id="battle-enemy-atk">5</span>

                            </div>
                        </div>
                    </div>
                    <div class="battle-actions">
                        <button class="battle-action-btn attack" id="battle-btn-attack">âš”ï¸ æ”»å‡»</button>
                        <button class="battle-action-btn flee" id="battle-btn-flee">ğŸƒ é€ƒè·‘</button>
                    </div>
                </div>
            </div>

            <!-- NPCå¯¹è¯æ¨¡æ€æ¡† -->
            <div id="npc-modal">
                <div class="npc-modal-content">
                    <div class="npc-modal-header">
                        <span class="npc-modal-icon" id="npc-modal-icon">ğŸ‘¤</span>
                        <span class="npc-modal-name" id="npc-modal-name">NPCåç§°</span>
                    </div>
                    <div class="npc-dialogue" id="npc-dialogue">
                        å¯¹è¯å†…å®¹
                    </div>
                    <div class="npc-actions" id="npc-actions">
                    </div>
                </div>
            </div>

            <!-- èƒŒåŒ…æ¨¡æ€æ¡† -->
            <div id="inventory-modal">
                <div class="inventory-modal-content">
                    <div class="inventory-header">
                        <span class="inventory-title">ğŸ’ èƒŒåŒ…</span>
                    </div>
                    <!-- æ­¦å™¨è£…å¤‡æ§½ -->
                    <div class="equipment-section">
                        <div class="equipment-title">âš”ï¸ æ­¦å™¨æ§½</div>
                        <div class="weapon-slot" id="weapon-slot">
                            <div class="empty-slot">ç©º</div>
                        </div>
                    </div>
                    <div class="inventory-grid" id="inventory-grid">
                    </div>
                    <button class="inventory-close-btn" id="btn-close-inventory">å…³é—­</button>
                </div>
            </div>
        </div>

        <!-- å³ä¾§æ—¥å¿—åŒºåŸŸ -->
        <div id="log-container">
            <div class="log-header">
                <span class="log-title">ğŸ“œ å†’é™©æ—¥å¿—</span>
                <button class="clear-log-btn" id="btn-clear-log">æ¸…ç©ºæ—¥å¿—</button>
            </div>
            <div id="log-section">
                <div class="log-entry system">æ¬¢è¿æ¥åˆ°å†’é™©ä¸–ç•Œï¼</div>
            </div>
            <button id="btn-close-log">å…³é—­æ—¥å¿—</button>
        </div>

        <!-- æŸ¥çœ‹æ—¥å¿—æŒ‰é’®ï¼ˆç§»åŠ¨ç«¯ï¼‰ -->
        <button id="btn-show-log">ğŸ“œ<br>æ—¥å¿—</button>
    </div>

    <!-- æ¸¸æˆç»“æŸ/èƒœåˆ© æ¨¡æ€æ¡† -->
    <div id="game-over-modal" class="game-over-modal">
        <div class="game-over-modal-content">
            <h2 class="game-over-modal-title" id="game-over-modal-title">æ¸¸æˆç»“æŸ</h2>
            <p id="game-over-modal-msg">ä½ å€’ä¸‹äº†...</p>
            <br>
            <button class="primary" onclick="game.restart()">é‡æ–°å¼€å§‹</button>
        </div>
    </div>

    <script>

        const MONSTER_CONFIG_STR = `
æ€ªç‰©åç§°,è¡€é‡æˆé•¿æœ€ä½,è¡€é‡æˆé•¿æœ€é«˜,ç‰©æ”»æˆé•¿æœ€ä½,ç‰©æ”»æˆé•¿æœ€é«˜,ç»éªŒå¥–åŠ±ç³»æ•°,ç‰©å“å¥–åŠ±ç³»æ•°
é’è›™,50,70,-10,10,1,1
æ¾é¼ ,40,60,45,65,1,1
å…”å­,55,75,-10,10,1,1
è›‡,40,60,45,65,1,1
çŒ´å­,40,60,50,70,1,1
å±±çŒ«,45,65,-10,10,1,1
ç‹ç‹¸,40,60,50,70,1,1
é‡ç‹—,45,65,50,70,1,1
`

        const MAP_CONFIG_STR = `
name,level,description,monster
æ½ä»™é•‡,1,ä»™é£é“éª¨çš„æ½ä»™é•‡ï¼Œæ˜¯ä¿®ä»™è€…çš„èµ·ç‚¹ã€‚,
æ½ä»™é•‡å¤–,2,æ½ä»™é•‡éƒŠå¤–ï¼Œæœ‰ä¸€äº›é‡å…½å‡ºæ²¡ã€‚,é’è›™:2/æ¾é¼ :3
å§é¾™å¡,7,ä¼ è¯´ä¸­çš„å§é¾™å¡ï¼Œæ®è¯´æœ‰é¾™æ°”æ±‡èšã€‚,å…”å­:6/è›‡:8
å®˜é“å—,10,é€šå¾€åŒ—æ–¹çš„å®˜é“å—æ®µï¼Œå±é™©é‡é‡ã€‚,çŒ´å­:10/å±±çŒ«:11
å®˜é“åŒ—,12,å®˜é“åŒ—æ®µï¼Œæ›´åŠ å‡¶é™©ã€‚,ç‹ç‹¸:13/é‡ç‹—:14
å¤©å¢‰åŸ,10,æœ€ç¹åæœ€çƒ­é—¹åŒæ—¶ä¹Ÿæ˜¯æ²»å®‰æœ€å¥½çš„åŸé•‡ã€‚,
`

        // (a,b,x,y) ï¼šaå’Œbæ˜¯åŒå‘è¿æ¥ï¼Œxä»£è¡¨aåˆ°bçš„killThresholdï¼Œyä»£è¡¨båˆ°açš„killThreshold
        const MAP_CONNECTION_CONFIG_STR = `
(æ½ä»™é•‡,æ½ä»™é•‡å¤–,0,2)
(æ½ä»™é•‡,å®˜é“å—,0,3)
(æ½ä»™é•‡å¤–,å§é¾™å¡,2,3)
(å®˜é“å—,å®˜é“åŒ—,3,3)
(å¤©å¢‰åŸ,å®˜é“åŒ—,0,3)
`

        const NPC_CONFIG_STR = `
map,name,icon,dialogue,sell_items
æ½ä»™é•‡,ç‹è€æ¿,ğŸ’Š,æ¬¢è¿å…‰ä¸´ï¼æˆ‘è¿™é‡Œæœ‰ä¸Šå¥½çš„è¯æã€‚è¦æ¥ç‚¹ä»€ä¹ˆå—ï¼Ÿ,æ­¢è¡€è‰/ä¸€å¶è‰/å…°èŠè‰/åœ°äº‘è‰
æ½ä»™é•‡,å¼ è€æ¿,âš”ï¸,æ¬¢è¿å…‰ä¸´å¼ æ°æ­¦å™¨é“ºï¼æˆ‘è¿™é‡Œæœ‰å„ç§ç¥å…µåˆ©å™¨ã€‚è¦çœ‹çœ‹å—ï¼Ÿ,é•¿æª/é“æª
`

        const ITEM_CONFIG_STR = `
name,icon,description,stackable,effect,amount,price,note
æ­¢è¡€è‰,ğŸŒ¿,ä½¿ç”¨åæ¢å¤100HP,1,heal,100,10,ä½¿ç”¨åæ¢å¤100HP
ä¸€å¶è‰,ğŸƒ,ä½¿ç”¨åæ¢å¤200HP,1,heal,200,25,ä½¿ç”¨åæ¢å¤200HP
å…°èŠè‰,ğŸŒ±,ä½¿ç”¨åæ¢å¤350HP,1,heal,350,45,ä½¿ç”¨åæ¢å¤350HP
åœ°äº‘è‰,ğŸŒ¾,ä½¿ç”¨åæ¢å¤600HP,1,heal,600,80,ä½¿ç”¨åæ¢å¤600HP
`

        const WEAPON_CONFIG_STR = `
name,icon,description,level,atk,price
é•¿æª,ğŸ”±,ä¸€æ”¯é•¿æª,1,58,300
é“æª,ğŸ”±,ä¸€æ”¯é“æª,10,179,600
`

        const ATTRIBUTE_TABLE = {
            atk: 'æ”»å‡»åŠ›',
            critRate: 'æš´å‡»ç‡',
            maxHp: 'æ°”è¡€',
        }

        const INVENTORY_MAX_SIZE = 20
        const GOLDEN_MONSTER_RATE = 0.01

        /**
         * æ¸¸æˆé€»è¾‘æ ¸å¿ƒ
         * åŒ…å«ï¼šç©å®¶ç±»ã€æ€ªç‰©ç”Ÿæˆã€æˆ˜æ–—é€»è¾‘ã€UIæ›´æ–°
         */

        // å·¥å…·å‡½æ•°
        function htmlStringToNode(htmlString) {
            const parser = new DOMParser();

            const doc = parser.parseFromString(htmlString, 'text/html');
            return doc.body.firstChild; // è¿”å›ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹
        }
        const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

        const nextLevelExpMax = (lv) => lv * lv * lv * 5;

        // è§£æMAP_CONFIG_STRï¼Œç”ŸæˆMAP_CONFIGï¼ˆåˆå¹¶MAP_METADATAå’ŒMONSTER_TYPESï¼‰
        function parseMapConfig(configStr) {
            const lines = configStr.trim().split('\n');
            const mapConfig = {};

            // è·³è¿‡æ ‡é¢˜è¡Œ
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const parts = line.split(',');
                if (parts.length < 4) continue;
                const name = parts[0].trim();
                const level = parts[1].trim();
                const description = parts[2].trim();
                const monsterStr = parts[3].trim();
                // è§£ææ€ªç‰©é…ç½®
                let monsters = [];
                if (monsterStr) {
                    monsters = monsterStr.split('/').map(monster => {
                        const [monsterName, monsterLevel] = monster.split(':');
                        return {
                            name: monsterName.trim(),
                            level: parseInt(monsterLevel.trim())
                        };
                    });
                }
                mapConfig[name] = {
                    name: name,
                    level: level ? parseInt(level) : undefined,
                    description: description,
                    monsters: monsters,
                    connections: {}
                };
            }

            return mapConfig;
        }

        // è§£æMAP_CONNECTION_CONFIG_STRï¼Œæ›´æ–°MAP_CONFIGä¸­çš„è¿æ¥å…³ç³»
        function parseMapConnectionConfig(configStr, mapConfig) {
            const lines = configStr.trim().split('\n');
            // è§£æè¿æ¥å…³ç³»
            for (const line of lines) {
                const trimmedLine = line.trim();
                if (!trimmedLine) continue;
                // è§£ææ ¼å¼: (a,b,x,y)
                const match = trimmedLine.match(/\(([^,]+),([^,]+),(\d+),(\d+)\)/);
                if (!match) continue;
                const [, a, b, x, y] = match;
                const mapA = mapConfig[a];
                const mapB = mapConfig[b];
                if (!mapA || !mapB) continue;
                // æ·»åŠ åŒå‘è¿æ¥
                // aåˆ°bçš„è¿æ¥
                mapA.connections[b] = {
                    killThreshold: parseInt(x),
                    name: b
                };
                // båˆ°açš„è¿æ¥
                mapB.connections[a] = {
                    killThreshold: parseInt(y),
                    name: a
                };
            }
            return mapConfig;
        }

        // è§£æMONSTER_CONFIG_STRï¼Œç”Ÿæˆæ€ªç‰©æˆé•¿å±æ€§é…ç½®
        function parseMonsterConfig(configStr) {
            const lines = configStr.trim().split('\n');

            const config = {};
            // è·³è¿‡æ ‡é¢˜è¡Œ
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const parts = line.split(',');
                if (parts.length < 7) continue;

                const name = parts[0].trim();
                config[name] = {
                    hpGrowthMin: parseInt(parts[1].trim()),
                    hpGrowthMax: parseInt(parts[2].trim()),
                    atkGrowthMin: parseInt(parts[3].trim()),
                    atkGrowthMax: parseInt(parts[4].trim()),
                    expRewardCoefficient: parseFloat(parts[5].trim()),
                    goldRewardCoefficient: parseFloat(parts[6].trim())
                };
            }
            return config;
        }

        // åˆå§‹åŒ–æ€ªç‰©æˆé•¿å±æ€§é…ç½®
        const MONSTER_GROWTH_CONFIG = parseMonsterConfig(MONSTER_CONFIG_STR);
        // åˆå§‹åŒ–åœ°å›¾é…ç½®ï¼ˆä»MAP_CONFIG_STRå’ŒMAP_CONNECTION_CONFIG_STRè§£æï¼‰
        let MAP_CONFIG = parseMapConfig(MAP_CONFIG_STR);
        MAP_CONFIG = parseMapConnectionConfig(MAP_CONNECTION_CONFIG_STR, MAP_CONFIG);
        // è§£æITEM_CONFIG_STRï¼Œç”Ÿæˆç‰©å“é…ç½®
        function parseItemConfig(configStr) {
            const lines = configStr.trim().split('\n');
            const config = {};

            // è·³è¿‡æ ‡é¢˜è¡Œ
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const parts = line.split(',');
                if (parts.length < 8) continue;

                const name = parts[0].trim();
                config[name] = {
                    id: name,
                    name: name,
                    icon: parts[1].trim(),
                    description: parts[2].trim(),
                    stackable: parts[3].trim() === '1',
                    effect: parts[4].trim(),
                    amount: parseInt(parts[5].trim()),
                    price: parseInt(parts[6].trim()),
                    note: parts[7].trim()
                };
            }

            return config;
        }

        // è§£æWEAPON_CONFIG_STRï¼Œç”Ÿæˆæ­¦å™¨é…ç½®
        function parseWeaponConfig(configStr) {
            const lines = configStr.trim().split('\n');
            const config = {};

            // è·³è¿‡æ ‡é¢˜è¡Œ
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const parts = line.split(',');
                if (parts.length < 6) continue;

                const name = parts[0].trim();
                config[name] = {
                    id: name,
                    name: name,
                    icon: parts[1].trim(),
                    description: parts[2].trim(),

                    type: 'weapon',
                    stackable: false,
                    level: parseInt(parts[3].trim()),
                    levelReq: parseInt(parts[3].trim()),
                    baseAtk: parseInt(parts[4].trim()),
                    price: parseInt(parts[5].trim())
                };
            }

            return config;
        }

        // è§£æNPC_CONFIG_STRï¼Œç”ŸæˆNPCé…ç½®
        function parseNPCConfig(configStr, itemConfigAll) {
            const lines = configStr.trim().split('\n');
            const config = {};

            // è·³è¿‡æ ‡é¢˜è¡Œ
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const parts = line.split(',');
                if (parts.length < 5) continue;

                const mapName = parts[0].trim();
                const npcName = parts[1].trim();
                const icon = parts[2].trim();
                const dialogue = parts[3].trim();
                const sellItemsStr = parts[4].trim();

                // è§£æsell_itemså­—æ®µï¼ˆä½¿ç”¨/åˆ†éš”ï¼‰
                const sellItems = sellItemsStr.split('/').map(item => item.trim()).filter(item => item);

                // ç”ŸæˆNPCçš„actions
                const actions = [];
                sellItems.forEach(itemName => {
                    let item = itemConfigAll[itemName];
                    if (item) {
                        actions.push({
                            type: 'buyItem',
                            itemName: item.name,
                        });
                    }
                });

                const npc = {
                    id: npcName,
                    name: npcName,
                    icon: icon,
                    dialogue: dialogue,
                    actions: actions
                };

                if (!config[mapName]) {
                    config[mapName] = [];
                }
                config[mapName].push(npc);
            }

            return config;
        }

        // åˆå§‹åŒ–ç‰©å“é…ç½®
        const ITEM_CONFIG_PARSED = parseItemConfig(ITEM_CONFIG_STR);
        const WEAPON_CONFIG_PARSED = parseWeaponConfig(WEAPON_CONFIG_STR);

        console.log(ITEM_CONFIG_PARSED, WEAPON_CONFIG_PARSED)

        // åˆå¹¶ç‰©å“å’Œæ­¦å™¨é…ç½®ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
        const ITEM_CONFIG = { ...ITEM_CONFIG_PARSED, ...WEAPON_CONFIG_PARSED };

        // åˆå§‹åŒ–NPCé…ç½®
        const NPC_CONFIG = parseNPCConfig(NPC_CONFIG_STR, ITEM_CONFIG);
        console.log(NPC_CONFIG)

        // è£…å¤‡å“è´¨å®šä¹‰
        const ITEM_QUALITY = {
            WHITE: 'white',
            GOLD: 'gold'
        };

        // è£…å¤‡å“è´¨é…ç½®
        const QUALITY_CONFIG = {
            white: {
                name: 'ç™½è‰²',
                color: '#ffffff',

                borderColor: '#aaaaaa'
            },
            gold: {
                name: 'é‡‘è‰²',
                color: '#ffd700',
                borderColor: '#ffd700'
            }
        };

        // ç”Ÿæˆé‡‘è‰²å“è´¨è£…å¤‡çš„é¢å¤–å±æ€§
        function generateGoldenItemStats(itemConfig) {
            const level = itemConfig.level;
            const stats = [];

            // å¯é€‰å±æ€§æ± 
            const availableStats = [
                {
                    type: 'maxHp',
                    name: 'æœ€å¤§ç”Ÿå‘½å€¼',
                    min: level * 20,
                    max: level * 40
                },
                {
                    type: 'critRate',
                    name: 'æš´å‡»ç‡',
                    min: 5,
                    max: 30
                },
                {
                    type: 'atk',
                    name: 'æ”»å‡»åŠ›',
                    min: level * 10,

                    max: level * 20
                }
            ];

            // éšæœºé€‰æ‹©3ä¸ªå±æ€§ï¼Œå…è®¸é‡å¤ä½†æ¯ä¸ªå±æ€§æœ€å¤šé‡å¤ä¸€æ¬¡
            const selectedStats = [];
            const statCounts = {}; // è®°å½•æ¯ä¸ªå±æ€§è¢«é€‰ä¸­çš„æ¬¡æ•°

            for (let i = 0; i < 3; i++) {
                // ç­›é€‰å‡ºæœªè¢«é€‰ä¸­æˆ–åªé€‰ä¸­è¿‡ä¸€æ¬¡çš„å±æ€§
                const availableOptions = availableStats.filter(stat => {
                    const count = statCounts[stat.type] || 0;
                    return count < 2; // æœ€å¤šå…è®¸é‡å¤ä¸€æ¬¡
                });

                if (availableOptions.length === 0) break;

                const index = randomInt(0, availableOptions.length - 1);
                const selectedStat = availableOptions[index];
                selectedStats.push(selectedStat);

                // è®°å½•é€‰ä¸­æ¬¡æ•°
                statCounts[selectedStat.type] = (statCounts[selectedStat.type] || 0) + 1;
            }

            // ä¸ºæ¯ä¸ªé€‰ä¸­çš„å±æ€§ç”Ÿæˆéšæœºå€¼
            selectedStats.forEach(stat => {
                const value = randomInt(stat.min, stat.max);
                stats.push({
                    type: stat.type,
                    name: stat.name,
                    value: value
                });
            });

            return stats;
        }

        class Game {
            constructor() {
                this.init();
                this.cacheUI();
                this.bindEvents();
                this.updateUI();
            }

            init() {
                this.player = {
                    hp: 0,
                    lv: 1,
                    exp: 0,
                    gold: 0,
                    inventory: [],
                    equippedWeapon: null
                };
                this.player.hp = this.calculateTotalMaxHp()
                this.enemy = null;
                this.inBattle = false;

                this.isAttacking = false;
                this.currentMap = 'æ½ä»™é•‡';
                this.mapKillCounts = {};
                this.battleForConnection = null;
                this.currentNPC = null;
                this.initCurrentMapKillCounts(null);
            }

            cacheUI() {
                this.ui = {
                    hp: document.getElementById('player-hp'),
                    hpBar: document.getElementById('hp-bar'),
                    lv: document.getElementById('player-lv'),
                    atk: document.getElementById('player-atk'),
                    exp: document.getElementById('player-exp'),
                    expBar: document.getElementById('exp-bar'),
                    gold: document.getElementById('player-gold'),
                    crit: document.getElementById('player-crit'),
                    log: document.getElementById('log-section'),
                    btnClearLog: document.getElementById('btn-clear-log'),
                    gameOverModal: document.getElementById('game-over-modal'),
                    gameOverModalTitle: document.getElementById('game-over-modal-title'),
                    gameOverModalMsg: document.getElementById('game-over-modal-msg'),
                    currentMapName: document.getElementById('current-map-name'),
                    mapButtons: document.getElementById('map-buttons'),
                    battleModal: document.getElementById('battle-modal'),
                    battleEnemyName: document.getElementById('battle-enemy-name'),
                    battlePlayerHp: document.getElementById('battle-player-hp'),
                    battlePlayerHpFill: document.getElementById('battle-player-hp-fill'),
                    battlePlayerAtk: document.getElementById('battle-player-atk'),
                    battlePlayerCrit: document.getElementById('battle-player-crit'),
                    battleEnemyHp: document.getElementById('battle-enemy-hp'),
                    battleEnemyHpFill: document.getElementById('battle-enemy-hp-fill'),
                    battleEnemyAtk: document.getElementById('battle-enemy-atk'),
                    battleBtnAttack: document.getElementById('battle-btn-attack'),
                    battleBtnFlee: document.getElementById('battle-btn-flee'),
                    battleStatus: document.getElementById('battle-status'),
                    npcModal: document.getElementById('npc-modal'),
                    npcModalIcon: document.getElementById('npc-modal-icon'),
                    npcModalName: document.getElementById('npc-modal-name'),
                    npcDialogue: document.getElementById('npc-dialogue'),
                    npcActions: document.getElementById('npc-actions'),
                    npcTitle: document.getElementById('npc-title'),
                    npcList: document.getElementById('npc-list'),

                    btnInventory: document.getElementById('btn-inventory'),
                    inventoryModal: document.getElementById('inventory-modal'),
                    inventoryGrid: document.getElementById('inventory-grid'),
                    btnCloseInventory: document.getElementById('btn-close-inventory')
                };
            }

            // ç»‘å®šäº‹ä»¶
            bindEvents() {
                this.ui.btnClearLog.onclick = () => this.clearLog();
                this.ui.battleBtnAttack.onclick = () => this.playerAttack();
                this.ui.battleBtnFlee.onclick = () => this.playerFlee();
                this.ui.btnInventory.onclick = () => this.openInventory();
                this.ui.btnCloseInventory.onclick = () => this.closeInventory();

                // ç§»åŠ¨ç«¯æ—¥å¿—æŒ‰é’®äº‹ä»¶
                const btnShowLog = document.getElementById('btn-show-log');
                const btnCloseLog = document.getElementById('btn-close-log');
                const logContainer = document.getElementById('log-container');

                btnShowLog.onclick = () => logContainer.classList.add('show');
                btnCloseLog.onclick = () => logContainer.classList.remove('show');
            }

            // æ—¥å¿—ç³»ç»Ÿ
            log(msg, type = '') {
                while (this.ui.log.children.length > 100) {
                    this.ui.log.firstElementChild.remove()
                }
                const div = document.createElement('div');
                div.className = `log-entry ${type}`;
                div.innerText = `${msg}`;
                this.ui.log.appendChild(div);
                this.ui.log.scrollTop = this.ui.log.scrollHeight;
            }

            clearLog() {
                this.ui.log.querySelectorAll('.log-entry').forEach(entry => entry.remove());
                this.log('æ—¥å¿—å·²æ¸…ç©º', 'system');
            }

            // UIæ›´æ–°
            updateUI() {
                this.updatePlayerStats();
                this.updateBattleModalUI();
                this.updateMapUI();
                this.updateInventoryButton();
            }

            updatePlayerStats() {
                const totalMaxHp = this.calculateTotalMaxHp();
                const maxExp = this.calculateMaxExp()
                const hpPercent = (this.player.hp / totalMaxHp) * 100;
                const expPercent = (this.player.exp / maxExp) * 100;
                const totalAtk = this.calculateTotalAttack();
                const totalCrit = this.calculateTotalCritRate();

                this.ui.hp.innerText = `${this.player.hp}/${totalMaxHp}`;
                this.ui.hpBar.style.width = `${hpPercent}%`;
                this.ui.lv.innerText = this.player.lv;
                this.ui.atk.innerText = totalAtk;

                this.ui.exp.innerText = `${this.player.exp}/${maxExp}ï¼ˆ${Math.floor(expPercent)}%ï¼‰`;
                this.ui.expBar.style.width = `${expPercent}%`;
                this.ui.gold.innerText = this.player.gold;
                this.ui.crit.innerText = `${totalCrit}%`;
            }

            highlightStat(elementId) {
                const element = document.getElementById(elementId);
                if (element) {
                    const statItem = element.closest('.stat-item');
                    if (statItem) {
                        statItem.classList.add('highlight');
                        setTimeout(() => statItem.classList.remove('highlight'), 500);
                    }
                }
            }

            // èƒŒåŒ…ç³»ç»Ÿ
            updateInventoryButton() {
                this.ui.btnInventory.disabled = this.inBattle;
            }

            calculateTotalAttack() {
                let totalAtk = 100 + this.player.lv * 50;
                if (this.player.equippedWeapon) {
                    // æ­¦å™¨å¯¹è±¡ç›´æ¥åŒ…å«baseAtkå±æ€§
                    const baseConfig = WEAPON_CONFIG_PARSED[this.player.equippedWeapon.itemId]
                    totalAtk += baseConfig.baseAtk;
                    // åŠ ä¸Šè£…å¤‡çš„é¢å¤–æ”»å‡»åŠ›ï¼ˆæ”¯æŒé‡å¤å±æ€§ï¼‰
                    if (this.player.equippedWeapon.extraStats) {
                        const atkStats = this.player.equippedWeapon.extraStats.filter(s => s.type === 'atk');
                        atkStats.forEach(atkStat => {
                            totalAtk += atkStat.value;
                        });
                    }
                }
                return totalAtk;
            }

            // è®¡ç®—æ€»æš´å‡»ç‡
            calculateTotalCritRate() {
                let totalCrit = 0;
                if (this.player.equippedWeapon && this.player.equippedWeapon.extraStats) {
                    const critStats = this.player.equippedWeapon.extraStats.filter(s => s.type === 'critRate');
                    critStats.forEach(critStat => {
                        totalCrit += critStat.value;
                    });
                }
                return totalCrit;
            }

            // è®¡ç®—æ€»æœ€å¤§ç”Ÿå‘½å€¼
            calculateTotalMaxHp() {
                let totalMaxHp = 200 + this.player.lv * 80;
                if (this.player.equippedWeapon && this.player.equippedWeapon.extraStats) {
                    const hpStats = this.player.equippedWeapon.extraStats.filter(s => s.type === 'maxHp');
                    hpStats.forEach(hpStat => {
                        totalMaxHp += hpStat.value;
                    });
                }
                return totalMaxHp;
            }

            calculateMaxExp() {
                let lv = this.player.lv
                return nextLevelExpMax(lv + 1)
            }


            openInventory() {
                if (this.inBattle) {
                    this.log("æˆ˜æ–—ä¸­æ— æ³•æ‰“å¼€èƒŒåŒ…ï¼", 'system');
                    return;
                }
                this.updateInventoryUI();
                this.updateWeaponSlot();
                this.ui.inventoryModal.style.display = 'flex';
            }

            updateWeaponSlot() {
                const weaponSlot = document.getElementById('weapon-slot');
                if (!weaponSlot) return;

                if (this.player.equippedWeapon) {
                    const weapon = this.player.equippedWeapon;
                    const baseInfo = WEAPON_CONFIG_PARSED[weapon.itemId]
                    weaponSlot.className = 'weapon-slot has-weapon';

                    let quality = '';
                    let extraStatsText = '';

                    if (weapon.extraStats) {
                        quality = 'quality-gold';
                        extraStatsText = '<br>';
                        weapon.extraStats.forEach(stat => {
                            extraStatsText += `<span class="quality-blue">${ATTRIBUTE_TABLE[stat.type]} +${stat.value}</span> `;
                        });
                    }

                    weaponSlot.innerHTML = `
                <div class="equipped-weapon">
                    <span class="equipped-weapon-icon">${baseInfo.icon}</span>
                    <div class="equipped-weapon-info">
                        <span class="equipped-weapon-name ${quality}">${baseInfo.name}</span>
                        <span>æ­¦å™¨ç­‰çº§   ${weapon.levelReq ?? baseInfo.level}</span>
                        <span>åŸºç¡€æ”»å‡»åŠ› +${baseInfo.baseAtk}</span>
                        ${extraStatsText}
                    </div>
                    <button class="unequip-btn" onclick="game.unequipWeapon()">å¸ä¸‹</button>
                </div>
            `;
                } else {
                    weaponSlot.className = 'weapon-slot';
                    weaponSlot.innerHTML = '<div class="empty-slot">ç©º</div>';
                }
            }

            closeInventory() {
                this.ui.inventoryModal.style.display = 'none';
            }

            updateInventoryUI() {
                this.ui.inventoryGrid.innerHTML = '';
                const inventory = this.player.inventory;

                if (inventory.length === 0) {
                    this.ui.inventoryGrid.innerHTML = '<div class="empty-inventory">èƒŒåŒ…æ˜¯ç©ºçš„...</div>';
                    return;
                }

                inventory.forEach((item, index) => {
                    const itemConfig = ITEM_CONFIG[item.itemId];
                    if (!itemConfig) return;


                    const itemElement = document.createElement('div');
                    itemElement.className = 'inventory-item';

                    let canUse = false;
                    let actionLabel = 'ä½¿ç”¨';
                    let actionType = 'use';

                    let extraStatsText = '';
                    if (item.extraStats) {
                        extraStatsText = '<div style="color: #7f7fff;">';
                        item.extraStats.forEach(stat => {
                            extraStatsText += `${ATTRIBUTE_TABLE[stat.type]}+${stat.value} `;
                        });
                        extraStatsText += '</div>';
                    }

                    if (itemConfig.type === 'weapon') {
                        canUse = this.player.lv >= itemConfig.levelReq;
                        actionLabel = 'ä½©æˆ´';
                        actionType = 'equip';
                    } else if (itemConfig.effect === 'heal') {
                        canUse = this.player.hp < this.calculateTotalMaxHp();
                        actionType = 'use';
                    }

                    itemElement.innerHTML = `
                <div class="inventory-item-base">
                    <span class="inventory-item-icon">${itemConfig.icon}</span>
                    <span class="inventory-item-name quality-${item.quality}">${itemConfig.name}</span>
                    <span class="inventory-item-description">${itemConfig.description}</span>
                    ${itemConfig.stackable ? `<span class="inventory-item-count">x${item.count}</span>` : ''}
                    ${extraStatsText}
                </div>
                <div class="inventory-item-actions">
                    <button class="inventory-item-btn ${actionType}" ${!canUse ? 'disabled' : ''}>${actionLabel}</button>
                    <button class="inventory-item-btn sell">å‡ºå”®($${itemConfig.price / 5})</button>
                </div>
            `;

                    const actionBtn = itemElement.querySelector(`.${actionType}`);
                    actionBtn.onclick = () => {
                        if (actionType === 'equip') {
                            this.equipWeapon(index);
                        } else {
                            this.useItem(index);
                        }
                    };
                    const sellBtn = itemElement.querySelector(`button.sell`)
                    if (sellBtn) {
                        sellBtn.onclick = () => this.sellItem(index);
                    }

                    this.ui.inventoryGrid.appendChild(itemElement);
                });
            }

            addItem(newItem) {
                const itemConfig = ITEM_CONFIG[newItem.itemId];
                if (!itemConfig) return false;
                console.log('newItem', newItem)
                let addNew = true;

                // æ ¹æ®æ˜¯å¦å¯å åŠ åˆ¤æ–­å¤„ç†é€»è¾‘
                if (itemConfig.stackable) {
                    // å¯å åŠ ç‰©å“ï¼šéå† inventory æŸ¥æ‰¾æ˜¯å¦å·²å­˜åœ¨ç›¸åŒ itemId
                    const existingItem = this.player.inventory.find(item => item.itemId === newItem.itemId);
                    if (existingItem) {
                        // å·²å­˜åœ¨ï¼Œç›´æ¥æ·»åŠ æ•°é‡
                        existingItem.count += newItem.count;
                        addNew = false;
                    }
                }

                if (addNew) {
                    if (this.player.inventory.length >= INVENTORY_MAX_SIZE) {
                        this.log(`ä½ çš„èƒŒåŒ…å·²æ»¡ï¼Œæ— æ³•è£…ä¸‹ã€${itemConfig.name}ã€‘`)
                        return false
                    }
                    if (!newItem.id) {
                        newItem.id = this.generateUniqueId()
                    }
                    this.player.inventory.push(newItem)
                }

                this.log(`ä½ è·å¾—äº†ã€${itemConfig.name}ã€‘${itemConfig.stackable ? `x${newItem.count}` : ''}`, 'system');
                return true;
            }

            // ç”Ÿæˆå”¯ä¸€ ID
            generateUniqueId() {
                return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }

            removeItem(index, count = 1) {
                if (index < 0 || index >= this.player.inventory.length) return false;

                const item = this.player.inventory[index];
                const itemConfig = ITEM_CONFIG[item.itemId];

                if (itemConfig.stackable) {
                    item.count -= count;
                    if (item.count <= 0) {
                        this.player.inventory.splice(index, 1);
                    }
                } else {
                    this.player.inventory.splice(index, 1);
                }
                return true;
            }

            useItem(index) {
                if (index < 0 || index >= this.player.inventory.length) return;

                const item = this.player.inventory[index];
                const itemConfig = ITEM_CONFIG[item.itemId];

                if (!itemConfig) return;

                switch (itemConfig.effect) {
                    case 'heal':
                        const maxHp = this.calculateTotalMaxHp()
                        if (this.player.hp >= maxHp) {
                            this.log("ä½ çš„ç”Ÿå‘½å€¼å·²ç»æ»¡äº†ï¼", 'system');
                            return;
                        }
                        const oldHp = this.player.hp;
                        this.player.hp = Math.min(maxHp, this.player.hp + itemConfig.amount);
                        const healed = this.player.hp - oldHp;
                        this.removeItem(index, 1);

                        this.log(`ä½¿ç”¨äº†ã€${itemConfig.name}ã€‘ï¼Œæ¢å¤äº†${healed}ç‚¹ç”Ÿå‘½å€¼ã€‚`, 'system');
                        this.highlightStat('player-hp');
                        break;
                }

                this.updateInventoryUI();
                this.updateUI();
            }

            sellItem(index) {
                if (index < 0 || index >= this.player.inventory.length) return;

                const item = this.player.inventory[index];
                const itemConfig = ITEM_CONFIG[item.itemId];

                if (!itemConfig) return;

                this.removeItem(index)
                let sellPrice = Math.floor(itemConfig.price / 5)
                this.player.gold += sellPrice

                this.log(`ä½ å‡ºå”®äº†ã€${itemConfig.name}ã€‘ï¼Œå¾—åˆ°${sellPrice}ä¸ªé‡‘å¸ã€‚`, 'system');

                this.updateInventoryUI();
                this.updateUI();
            }

            updatePlayerStat() {
                this.player.hp = Math.min(this.player.hp, this.calculateTotalMaxHp())
            }

            equipWeapon(index) {
                if (index < 0 || index >= this.player.inventory.length) return;

                const item = this.player.inventory[index];
                const weapon = ITEM_CONFIG[item.itemId];


                if (!weapon || weapon.type !== 'weapon') return;

                if (this.player.lv < item.levelReq) {
                    this.log(`ä½ çš„ç­‰çº§ä¸è¶³ï¼éœ€è¦è¾¾åˆ°${item.levelReq}çº§æ‰èƒ½ä½©æˆ´ã€${weapon.name}ã€‘ã€‚`, 'system');
                    return;
                }

                let oldWeapon = this.player.equippedWeapon;
                // åˆ›å»ºæ­¦å™¨å¯¹è±¡ï¼ŒåŒ…å«å”¯ä¸€idå’Œæ‰€æœ‰å±æ€§
                this.player.equippedWeapon = item;
                this.log(`è£…å¤‡äº†ã€${weapon.name}ã€‘ã€‚`, 'system');
                this.removeItem(index, 1);

                if (oldWeapon) {
                    this.addItem(oldWeapon);
                }

                this.updatePlayerStat()

                this.highlightStat('player-atk');
                this.highlightStat('player-crit');
                this.updateWeaponSlot();
                this.updateInventoryUI();
                this.updateUI();
            }

            unequipWeapon() {
                if (!this.player.equippedWeapon) return;

                const weapon = this.player.equippedWeapon;
                if (!this.addItem(weapon)) {
                    return
                }
                this.player.equippedWeapon = null;

                const baseInfo = WEAPON_CONFIG_PARSED[weapon.itemId]
                this.log(`å¸ä¸‹äº† ${baseInfo.name}ã€‚`, 'system');

                this.updatePlayerStat()

                this.highlightStat('player-atk');
                this.highlightStat('player-crit');
                this.updateWeaponSlot();

                this.updateInventoryUI();
                this.updateUI();
            }

            // æˆ˜æ–—ç³»ç»Ÿ
            updateBattleModalUI() {
                if (!this.enemy || !this.inBattle) return;

                const totalMaxHp = this.calculateTotalMaxHp();
                const playerHpPercent = Math.max(0, (this.player.hp / totalMaxHp) * 100);
                const enemyHpPercent = Math.max(0, (this.enemy.hp / this.enemy.maxHp) * 100);
                const totalAtk = this.calculateTotalAttack();
                const totalCrit = this.calculateTotalCritRate();

                this.ui.battlePlayerHp.innerText = `${this.player.hp}/${totalMaxHp}`;
                this.ui.battlePlayerHpFill.style.width = `${playerHpPercent}%`;
                this.ui.battlePlayerAtk.innerText = totalAtk;
                this.ui.battlePlayerCrit.innerText = `${totalCrit}%`;

                // åˆ¤æ–­æ˜¯å¦ä¸ºé‡‘è‰²æ€ªç‰©ï¼Œè®¾ç½®ä¸åŒçš„æ˜¾ç¤ºæ ·å¼
                this.ui.battleEnemyName.innerText = `ğŸ‘¹ ${this.enemy.name}ï¼ˆLv.${this.enemy.level}ï¼‰`;
                if (this.enemy.isGolden) {
                    this.ui.battleEnemyName.classList.add('gold-enemy');
                } else {
                    this.ui.battleEnemyName.classList.remove('gold-enemy');
                }

                this.ui.battleEnemyHp.innerText = `${this.enemy.hp}/${this.enemy.maxHp}`;
                this.ui.battleEnemyHpFill.style.width = `${enemyHpPercent}%`;
                this.ui.battleEnemyAtk.innerText = this.enemy.atk;
            }

            showBattleModal() {
                this.ui.battleModal.style.display = 'flex';
            }

            closeBattleModal() {
                this.ui.battleModal.style.display = 'none';
                // ç§»é™¤é‡‘è‰²æ€ªç‰©æ ·å¼
                if (this.ui.battleEnemyName) {
                    this.ui.battleEnemyName.classList.remove('gold-enemy');
                }
            }

            explore() {
                const mapConfig = MAP_CONFIG[this.currentMap];
                const mapMonsters = mapConfig ? mapConfig.monsters : [];
                if (!mapMonsters || mapMonsters.length === 0) {
                    this.log("è¿™é‡Œæ²¡æœ‰æ€ªç‰©å‡ºæ²¡ã€‚", 'system');
                    return;
                }

                const template = mapMonsters[randomInt(0, mapMonsters.length - 1)];
                const growthConfig = MONSTER_GROWTH_CONFIG[template.name];

                if (!growthConfig) {
                    return;
                }

                // åˆ¤æ–­æ˜¯å¦ä¸ºé‡‘è‰²æ€ªç‰©
                const isGolden = Math.random() < GOLDEN_MONSTER_RATE;

                // é‡‘è‰²æ€ªç‰©å±æ€§æå‡50%
                const multiplier = isGolden ? 4 : 1;

                // æ ¹æ®æˆé•¿å±æ€§èŒƒå›´éšæœºå–å€¼ï¼ˆ0%-60%ï¼‰

                const hpGrowthRange = growthConfig.hpGrowthMax - growthConfig.hpGrowthMin;
                const hpGrowthPercent = Math.random() * 0.6; // 0%-60%
                const hpGrowth = Math.floor(growthConfig.hpGrowthMin + hpGrowthRange * hpGrowthPercent);

                const atkGrowthRange = growthConfig.atkGrowthMax - growthConfig.atkGrowthMin;
                const atkGrowthPercent = Math.random() * 0.6; // 0%-60%
                const atkGrowth = Math.floor(growthConfig.atkGrowthMin + atkGrowthRange * atkGrowthPercent);

                // è®¡ç®—æ€ªç‰©å±æ€§
                // è¡€é‡è®¡ç®—å…¬å¼ï¼š50 + ç­‰çº§ * è¡€é‡æˆé•¿
                const baseHp = 50 + template.level * hpGrowth;
                // æ”»å‡»åŠ›è®¡ç®—å…¬å¼ï¼š10 + ç­‰çº§ * max(0, æ”»å‡»åŠ›æˆé•¿)
                const baseAtk = 10 + template.level * Math.max(0, atkGrowth);

                // è®¡ç®—æ‰è½é‡‘å¸ï¼šï¼ˆæ€ªç‰©ç­‰çº§ * ç‰©å“å¥–åŠ±ç³»æ•°ï¼‰Â±50%ï¼Œå‘ä¸Šå–æ•´
                const goldBase = template.level * growthConfig.goldRewardCoefficient;
                const goldVariance = goldBase * 0.5;
                let gold = Math.ceil(goldBase + randomInt(-goldVariance, goldVariance));

                // è®¡ç®—è·å¾—ç»éªŒï¼šï¼ˆæ€ªç‰©ç­‰çº§ * ç»éªŒå¥–åŠ±ç³»æ•° * 10ï¼‰Â±10%ï¼Œå‘ä¸Šå–æ•´
                const expBase = template.level * growthConfig.expRewardCoefficient * 10;
                const expVariance = expBase * 0.1;
                let exp = Math.ceil(expBase + randomInt(-expVariance, expVariance));

                this.enemy = {
                    name: template.name,
                    level: template.level,
                    maxHp: Math.floor(baseHp * multiplier),
                    hp: 0,
                    atk: baseAtk,
                    exp: Math.floor(exp * multiplier * 2),
                    gold: Math.floor(gold * multiplier * 2),
                    isGolden: isGolden
                };
                this.enemy.hp = this.enemy.maxHp;

                this.inBattle = true;

                if (isGolden) {
                    this.log(`ä½ å››å¤„æ¢ç´¢ï¼Œé‡åˆ°äº†ä¸€åªä¼ è¯´ä¸­çš„ã€${this.enemy.name}ã€‘ï¼`, 'legendary');
                } else {
                    this.log(`ä½ å››å¤„æ¢ç´¢ï¼Œé‡åˆ°äº†ä¸€åªé‡ç”Ÿçš„ã€${this.enemy.name}ã€‘ï¼`, 'system');
                }

                this.showBattleModal();

                this.updateUI();
            }

            playerAttack() {
                if (!this.inBattle || this.isAttacking) return;

                this.isAttacking = true;
                const isCrit = Math.random() < (this.calculateTotalCritRate() / 100);
                const totalAtk = this.calculateTotalAttack();
                let damage = Math.floor(totalAtk * (Math.random() * 0.1 + 0.95));

                if (isCrit) {
                    damage = Math.floor(damage * 1.5);

                    this.log(`ä½ å‘èµ·äº†è‡´å‘½ä¸€å‡»ï¼å¯¹ã€${this.enemy.name}ã€‘é€ æˆäº†${damage}ç‚¹ä¼¤å®³ï¼`, 'critical');
                } else {
                    this.log(`ä½ æ”»å‡»äº†ã€${this.enemy.name}ã€‘ï¼Œé€ æˆäº†${damage}ç‚¹ä¼¤å®³ã€‚`, 'player-action');
                }

                this.enemy.hp -= damage;

                if (this.enemy.hp <= 0) {
                    this.winBattle();
                } else {
                    setTimeout(() => this.enemyTurn(), 600);
                }

                this.isAttacking = false;
                this.updateUI();
            }

            enemyTurn() {
                if (!this.inBattle) return;

                const damage = Math.max(1, Math.floor(this.enemy.atk - (this.player.lv * 0.5)));
                this.player.hp -= damage;
                this.log(`ã€${this.enemy.name}ã€‘åå‡»äº†ï¼ä½ å—åˆ°äº†${damage}ç‚¹ä¼¤å®³ã€‚`, 'enemy-action');

                if (this.player.hp <= 0) {
                    this.player.hp = 0;
                    this.inBattle = false;
                    this.isAttacking = false;
                    this.closeBattleModal()
                    this.gameOver();
                }

                this.updateUI();
            }

            winBattle() {
                this.inBattle = false;
                this.isAttacking = false;

                let attenuation = this.player.lv - 2 > this.enemy.level
                let exp = this.enemy.exp
                let gold = this.enemy.gold
                if (attenuation) {
                    exp = Math.ceil(exp / 10);
                    gold = Math.ceil(gold / 10);
                }

                this.log(`ä½ å‡»è´¥äº†ã€${this.enemy.name}ã€‘ï¼è·å¾—${exp}ç»éªŒå’Œ${gold}ä¸ªé‡‘å¸ã€‚`, 'system');
                if (attenuation) {
                    this.log(`ç”±äºä½ çš„ç­‰çº§è¿œå¤§äºæ€ªç‰©ç­‰çº§ï¼Œå¥–åŠ±è¢«è¡°å‡ã€‚`, 'system');
                }
                // åˆ¤æ–­æ˜¯å¦ä¸ºé‡‘è‰²æ€ªç‰©
                if (this.enemy.isGolden) {
                    this.log(`ä½ å‡»è´¥äº†ä¼ è¯´ä¸­çš„ã€${this.enemy.name}ã€‘ï¼è·å¾— ${exp} ç»éªŒå’Œ ${gold} é‡‘å¸ã€‚`, 'legendary');

                    const dropLevel = Math.max(1, Math.floor(this.enemy.level / 10) * 10);
                    const eligibleWeapons = Object.values(WEAPON_CONFIG_PARSED).filter(item => {
                        return item.level === dropLevel;
                    });

                    if (eligibleWeapons.length > 0) {
                        // éšæœºé€‰æ‹©ä¸€ä¸ªç¬¦åˆç­‰çº§çš„è£…å¤‡
                        const itemConfig = eligibleWeapons[randomInt(0, eligibleWeapons.length - 1)];
                        const extraStats = generateGoldenItemStats(itemConfig);
                        this.addItem({
                            itemId: itemConfig.id,
                            quality: ITEM_QUALITY.GOLD,

                            extraStats: extraStats
                        });
                    }
                }

                this.player.exp += exp;
                this.player.gold += gold;

                this.updateKillProgress();
                this.checkLevelUp();
                this.enemy = null;
                this.closeBattleModal();
                this.updateUI();
            }

            updateKillProgress() {
                if (this.battleForConnection === null) return;

                this.mapKillCounts[this.battleForConnection]++;
                this.decreaseOtherMapProgress(this.battleForConnection);

                const mapConfig = MAP_CONFIG[this.currentMap];
                const connection = mapConfig.connections[this.battleForConnection];
                const threshold = connection.killThreshold;
                const killCount = this.mapKillCounts[this.battleForConnection];

                if (threshold > 0 && killCount === threshold) {
                    this.log(`æ­å–œï¼ä½ å·²å‡»è´¥${threshold}åªæ€ªç‰©ï¼Œè§£é”äº†å‰å¾€ã€${connection.name}ã€‘çš„é“è·¯ï¼`, 'critical');
                }

                this.battleForConnection = null;
            }

            decreaseOtherMapProgress(targetMapId) {
                const connections = MAP_CONFIG[this.currentMap].connections;
                for (const [otherMapId, connection] of Object.entries(connections)) {
                    if (otherMapId === targetMapId || connection.killThreshold === 0) continue;
                    this.mapKillCounts[otherMapId] = Math.max(0, (this.mapKillCounts[otherMapId] || 0) - 1);
                }
            }

            playerFlee() {
                if (!this.inBattle || this.isAttacking) {
                    this.log("æ­£åœ¨æˆ˜æ–—ä¸­ï¼Œæ— æ³•é€ƒè·‘ï¼", 'system');
                    return;
                }

                if (Math.random() > 0.5) {
                    this.log(`ä½ ç‹¼ç‹ˆåœ°é€ƒç¦»äº†ã€${this.enemy.name}ã€‘ï¼`, 'system');
                    this.inBattle = false;
                    this.enemy = null;
                    this.battleForConnection = null;
                    this.closeBattleModal();
                } else {
                    this.log(`é€ƒè·‘å¤±è´¥ï¼è¢«ã€${this.enemy.name}ã€‘æ‹¦ä½äº†å»è·¯ã€‚`, 'enemy-action');
                    this.isAttacking = true;
                    setTimeout(() => {
                        this.enemyTurn();
                        this.isAttacking = false;
                    }, 500);
                }
                this.updateUI();
            }

            gameOver(reason = 'die') {
                let title = 'ä½ ç‰ºç‰²äº†'
                let titleColor = 'red'
                let submsg = `ä½ åœ¨ç¬¬${this.player.lv}çº§å€’ä¸‹äº†ã€‚\nä½ çš„å†’é™©åˆ°æ­¤ç»“æŸã€‚`;
                if (reason === 'win') {

                    title = 'ä½ èƒœåˆ©äº†'
                    titleColor = 'green'
                    submsg = 'æ­å–œä½ åˆ°è¾¾å¤©å¢‰åŸï¼'
                }

                this.ui.gameOverModalTitle.innerText = title;
                this.ui.gameOverModalTitle.style.color = titleColor;
                this.ui.gameOverModalMsg.innerText = submsg
                this.ui.gameOverModal.style.display = 'flex';
            }

            checkLevelUp() {
                let maxExp = this.calculateMaxExp()
                while (this.player.exp >= maxExp) {
                    this.player.lv++;
                    this.player.exp -= maxExp;
                    maxExp = this.calculateMaxExp()

                    // å‡çº§æ—¶æ¢å¤åˆ°æœ€å¤§ç”Ÿå‘½å€¼ï¼ˆåŒ…å«è£…å¤‡åŠ æˆï¼‰
                    this.player.hp = this.calculateTotalMaxHp();

                    this.log(`æ­å–œï¼ä½ å‡çº§åˆ°äº† LV ${this.player.lv}ï¼çŠ¶æ€å·²å›æ»¡ã€‚`, 'critical');
                    ['player-lv', 'player-hp', 'player-atk', 'player-exp'].forEach(id => this.highlightStat(id));
                }
            }

            // åœ°å›¾ç³»ç»Ÿ
            updateMapUI() {
                const currentMapConfig = MAP_CONFIG[this.currentMap];
                this.ui.currentMapName.innerText = currentMapConfig.name;

                this.ui.mapButtons.innerHTML = '';
                this.renderExploreButton();
                this.renderMapButtons(currentMapConfig.connections);
                this.updateNPCUI();
            }

            renderExploreButton() {
                const mapConfig = MAP_CONFIG[this.currentMap];
                const mapMonsters = mapConfig ? mapConfig.monsters : [];
                if (!mapMonsters || mapMonsters.length === 0) return;

                const button = document.createElement('button');
                button.className = 'map-button primary';
                button.innerHTML = '<span>âš”ï¸</span> <span>å¯»æ‰¾æ€ªç‰©</span>';
                button.onclick = () => this.explore();
                button.disabled = this.inBattle;
                this.ui.mapButtons.appendChild(button);
            }

            renderMapButtons(connections) {
                for (const [targetMapId, connection] of Object.entries(connections)) {
                    const button = document.createElement('button');
                    button.className = 'map-button';

                    const killCount = this.mapKillCounts[targetMapId] || 0;
                    const threshold = connection.killThreshold;
                    const canTravel = killCount >= threshold;

                    if (this.currentMap === targetMapId) {
                        button.className += ' current';
                        button.innerHTML = `<span>ğŸ </span> <span>${connection.name}</span>`;
                        button.disabled = true;

                    } else if (canTravel) {
                        button.className += ' unlocked';
                        const label = threshold === 0 ? `å‰å¾€${connection.name}` : `å‰å¾€${connection.name}ï¼ˆ${killCount}/${threshold}ï¼‰`;
                        button.innerHTML = `<span>â¡ï¸</span> <span>${label}</span>`;
                        button.onclick = () => this.travelTo(targetMapId);
                    } else {
                        button.innerHTML = `<span>âš”ï¸</span> <span>å‰å¾€${connection.name}ï¼ˆ${killCount}/${threshold}ï¼‰</span>`;
                        button.onclick = () => this.tryTravelTo(targetMapId);
                    }

                    this.ui.mapButtons.appendChild(button);
                }
            }

            travelTo(targetMapId) {
                if (this.inBattle) {
                    this.log("æˆ˜æ–—ä¸­æ— æ³•ç§»åŠ¨ï¼", 'system');
                    return;
                }

                const connection = MAP_CONFIG[this.currentMap].connections[targetMapId];
                if ((this.mapKillCounts[targetMapId] || 0) < connection.killThreshold) {
                    this.log(`éœ€è¦å‡»è´¥${connection.killThreshold}åªæ€ªç‰©æ‰èƒ½å‰å¾€ã€${connection.name}ã€‘ï¼`, 'system');
                    return;
                }

                let previousMap = this.currentMap;
                this.currentMap = targetMapId;
                this.initCurrentMapKillCounts(previousMap);

                const newMapConfig = MAP_CONFIG[targetMapId];
                this.log(`ä½ æ¥åˆ°äº†ã€${newMapConfig.name}ã€‘ã€‚${newMapConfig.description}`, 'system');
                this.updateUI();

                if (targetMapId === 'å¤©å¢‰åŸ') {
                    this.gameOver('win')
                }
            }

            tryTravelTo(targetMapId) {
                if (this.inBattle) {
                    this.log("æˆ˜æ–—ä¸­æ— æ³•ç§»åŠ¨ï¼", 'system');
                    return;
                }

                const connection = MAP_CONFIG[this.currentMap].connections[targetMapId];
                if ((this.mapKillCounts[targetMapId] || 0) >= connection.killThreshold) {
                    this.travelTo(targetMapId);
                    return;
                }

                this.battleForConnection = targetMapId;
                this.log(`ä½ è¯•å›¾å‰å¾€ã€${connection.name}ã€‘ï¼Œä½†è·¯ä¸Šé‡åˆ°äº†æ€ªç‰©ï¼`, 'system');
                this.explore();
            }

            initCurrentMapKillCounts(previousMap) {
                this.mapKillCounts = {};

                if (previousMap) {
                    const returnConnection = MAP_CONFIG[this.currentMap].connections[previousMap];
                    if (returnConnection) {
                        this.mapKillCounts[previousMap] = returnConnection.killThreshold;
                    }
                }


                for (const [targetMapId] of Object.entries(MAP_CONFIG[this.currentMap].connections)) {
                    if (!this.mapKillCounts[targetMapId]) {
                        this.mapKillCounts[targetMapId] = 0;
                    }
                }
            }

            // NPCç³»ç»Ÿ
            updateNPCUI() {
                const npcs = NPC_CONFIG[this.currentMap] || [];
                this.ui.npcList.innerHTML = '';

                if (npcs.length === 0) {
                    this.ui.npcList.innerHTML = '<div class="no-npc">æ­¤åœ°ç©ºæ— ä¸€äºº...</div>';
                    return;
                }

                npcs.forEach(npc => {
                    const card = document.createElement('div');
                    card.className = 'npc-card';
                    card.innerHTML = `
                <span class="npc-icon">${npc.icon}</span>
                <div class="npc-info">
                    <span class="npc-name">${npc.name}</span>

                </div>
            `;
                    card.onclick = () => this.openNPCDialog(npc);
                    this.ui.npcList.appendChild(card);
                });
            }

            openNPCDialog(npc) {
                this.currentNPC = npc;
                this.ui.npcModalIcon.innerText = npc.icon;
                this.ui.npcModalName.innerText = npc.name;
                this.ui.npcDialogue.innerText = npc.dialogue;
                this.ui.npcActions.innerHTML = '';

                npc.actions.filter(action => action.type === 'buyItem').forEach(action => {
                    const item = ITEM_CONFIG[action.itemName]
                    let label = htmlStringToNode(`
                        <button class="npc-action-btn">
                        ${item.icon} ${item.name} ${item.description}ï¼ˆ${item.price}é‡‘å¸ï¼‰
                        </button>
                    `)
                    label.onclick = () => this.npcTransaction(action, action.type);
                    this.ui.npcActions.appendChild(label)
                })

                const closeButton = document.createElement('button');
                closeButton.className = 'npc-action-btn npc-close-btn';
                closeButton.innerText = 'ç¦»å¼€';
                closeButton.onclick = () => this.closeNPCDialog();
                this.ui.npcActions.appendChild(closeButton);

                this.ui.npcModal.style.display = 'flex';
            }

            closeNPCDialog() {
                this.ui.npcModal.style.display = 'none';
                this.currentNPC = null;
            }

            npcTransaction(action, type) {
                // éªŒè¯ç‰©å“é…ç½®æ˜¯å¦å­˜åœ¨
                const itemConfig = ITEM_CONFIG[action.itemName];
                if (!itemConfig) {
                    this.ui.npcDialogue.innerText = 'æŠ±æ­‰ï¼Œè¿™ä¸ªç‰©å“æš‚æ—¶æ— æ³•è´­ä¹°ã€‚';

                    return;
                }

                const itemPrice = itemConfig.price

                // éªŒè¯é‡‘å¸æ˜¯å¦è¶³å¤Ÿ
                if (this.player.gold < itemPrice) {
                    this.ui.npcDialogue.innerText = 'å“å‘€ï¼Œä½ çš„é‡‘å¸ä¸å¤Ÿå•Šï¼å»èµšç‚¹é’±å†æ¥å§ï¼';
                    this.log(`é‡‘å¸ä¸è¶³`, 'system');
                    return;
                }

                // å•†åº—è´­ä¹°çš„ç‰©å“ç»Ÿä¸€ä¸ºç™½è‰²å“è´¨
                if (!this.addItem({
                    itemId: itemConfig.id,
                    count: 1,
                    quality: ITEM_QUALITY.WHITE
                })) {
                    this.log(`è´­ä¹°å¤±è´¥`, 'system');
                    return
                }

                // æ‰£é™¤é‡‘å¸
                this.player.gold -= itemPrice;

                // è®°å½•äº¤æ˜“æ—¥å¿—
                this.log(`ä½ åœ¨ã€${this.currentNPC.name}ã€‘å¤„èŠ±è´¹äº†${itemPrice}ä¸ªé‡‘å¸è´­ä¹°äº†ã€${itemConfig.name}ã€‘ã€‚`, 'system');

                // æ›´æ–°NPCå¯¹è¯å’ŒUI
                this.ui.npcDialogue.innerText = 'è´­ä¹°æˆåŠŸ';
                this.highlightStat('player-gold');
                this.updateUI();
            }

            // æ¸¸æˆé‡å¯
            restart() {
                this.init();
                this.ui.log.innerHTML = '';
                this.log("æ–°çš„å†’é™©å¼€å§‹äº†...", 'system');
                this.ui.gameOverModal.style.display = 'none';
                this.updateUI();
            }
        }

        function renderEquipHtml(equip) {

        }

        // åˆå§‹åŒ–æ¸¸æˆ
        const game = new Game();
    </script>
</body>

</html>